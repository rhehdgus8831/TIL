# git merge

merge는 여러 브랜치에서 분산된 코드 변경 사항을 한 브랜치로 합치는 과정에 사용

2가지 병합방법

1. 기능 브랜치 병합(3-way merge): 별도의 브랜치에서 개발한 기능이 완성되면,
 그 기능을 포함하는 브랜치를 main 또는 master 브랜치와 병합하여 기능을 통합 됨.

2. 빠른 포워드 병합(fast-forward merge): 하나의 브랜치에서만 변경 사항이 있고 다른 브랜치는 변경되지 않은 경우에 발생
이 경우 Git은 단순히 브랜치 포인터를 앞으로 이동하게 됨

__________________________________________________________________________________________________________________________

# git conflict

Git 충돌(conflict)은 두 개 이상의 변경 사항이 Git의 병합 과정에서 서로 충돌할 때 발생하는 문제를 의미
주로 여러 사람이 동시에 같은 파일의 같은 부분을 변경했을 때 문제가 발생


충돌이 발생하면 직접 찾아서 수정해야함 

ex)
<<<<<<< HEAD          <<<<<<< HEAD는 현재 브랜치의 변경 사항이 시작하는 지점 
The quick brown fox...
=======              =======는 다른 브랜치의 변경 사항이 시작하는 지점
The quick blue fox...
>>>>>>> new_branc   >>>>>>> new_branch는 다른 브랜치의 변경 사항이 끝나는 지점


위쪽의 갈색여우와 아래쪽의 파란여우가 같은 파일에서 다른 내용으로 수정되었기 때문에
<=> 기호를 지우고 올바른 내용만 남겨두면 충돌이 해결


git status로 충돌이 발생한 파일 확인
파일 열고 충돌 마커 (<=>) 제거 후 저장
git add commit으로 충돌이 해결된 상태를 커밋



__________________________________________________________________________________________________________________________


# git diff

git diff는 소스코드 또는 파일에서 변경된 부분을 비교하고 이를 시각적으로 표시해주는 역할

케이스
1. 작업 트리와 인덱스(스테이징 영역) 사이의 차이를 보여줌
    즉, 아직 스테이징하지 않은 변경사항(아직 add하지 않은)을 볼 수 있음.
2. 두 커밋 사이의 차이를 보여줌

또한 병합 충돌이 발생했을 때 어떤 부분이 충돌했는지 확인할 때 도움이 됨

# git diff branch1..branch2

 두 개의 브랜치 간에 발생한 변경사항을 확인하는 데 사용됨
 이 명령어는 branch1와 branch2에서 각각의 최신 커밋 사이의 차이점을 보여


# git diff commit1..commit2

두 개의 커밋 간에 발생한 변경사항을 확인하는 데 사용됨
이 명령어는 commit1와 commit2 사이의 차이점을 보여줌


__________________________________________________________________________________________________________________________



# git stash


Git에서 제공하는 일시적인 작업 저장소
이를 사용하면 아직 완료되지 않은 변경사항을 일시적으로 저장할 수 있으며, 
나중에 다시 로드하여 작업을 계속할 수 있음.


작업 중인 브랜치를 전환하거나, 테스팅 및 디버깅, 중요하지 않은 변경사항을 보관할 때 용이함


관련 명령어

git stash list

스태쉬 리스트 보기

git stash [save] 

save는 생략 가능함 뒤에 추가로 "메세지"를 포함하여 명령어를 사용하면 나중에 확인 시 편맇마


git stash pop

가장 최근 stash를 적용하고 해당 stash를 바로 제거해줌


git stash apply

pop과 비슷하지만 해당 stash를 제거하지 않음
동일한 stash를 여러 번 적용할 때 용이


git stash drop stash@{1}

스태쉬 고유 번호를 입력하여 스태쉬 목록에서 삭제함
고유 번호를 입력하지 않으면 최근 순으로 삭제

git stash clear 

스태쉬 전체 삭제



__________________________________________________________________________________________________________________________

# Detached HEAD

브랜치가 없는 곳으로 이동할 수 있음

- **단순히 이전 커밋 내역 둘러보기**: 그냥 헤드를 분리시킨 상태로 이전 커밋의 파일들을 둘러볼 수 있음.
-  그리고 원래 브랜치로 돌아가 분리된 헤드를 다시 결합.
-  
- **새 브랜치 생성**: `git switch -c <new-branch>` 명령을 사용하여 현재 커밋을 기반으로 새 브랜치를 생성할 수 있음.
- 이를 통해 Detached HEAD 상태에서 만든 변경사항을 새 브랜치에 저장하고 참조할 수 있음.
-  보통 이전 커밋에서 새로운 작업을 시도해보고 싶을 때 사용.
-  
- **작업 내역 저장 후 체크아웃**: `git stash`를 사용하여 변경사항을 저장한 다음, 원하는 브랜치로 체크아웃할 수 있음.
- 이후에 해당 변경사항을 다시 로드하여 작업을 계속할 수 있음음.


# git checkout <commit-hash>

체크아웃 명령어를 사용하면 git은 해당 커밋으로 체크아웃되며 detached HEAD 상태가 됨 (커밋 해쉬는 커밋의 고유 번호)

*중요한점*
Detached HEAD 상태에서의 변경사항은 참조되지 않는 커밋이 되고,시간이 지나면 Git의 가비지 컬렉션에 의해 제거될 수 있으므로,
작업 내용을 유지하려면 적절한 브랜치에 체크인하는 것이 중요


# git checkout HEAD~1

git checkout HEAD~1 명령어는 현재 HEAD에서 한 단계 이전의 커밋으로 체크아웃하는데 사용

HEAD~1은 현재 커밋의 전 커밋 HEAD~2는 현재 커밋의 전 전 커밋을 가르킴

따라서 HEAD 명령어를 사용하면 이전 커밋으로 이동하여 작업을 수정하거나 복구할 수 있음

*중요한점*

이러한 체크아웃 또한 Detached HEAD 상태가 되기에 이 상태에서 새로운 커밋을 만들 경우 그 커밋은 어느 브랜치에도 속하지 않음
참조나 사용을 하려면 새로운 브랜치를 생성 후 커밋해야함

__________________________________________________________________________________________________________________________

#git Restore

작업 디렉토리(애드 전)나 인덱스의 변경사항(애드 후 커밋 전)을 특정 커밋의 상태로 되돌리는 데 사용됨.
이는 예기치 않게 수정한 파일을 원래 상태로 되돌리거나, 커밋하지 않은 변경사항을 제거하는 등의 용도로 활용될 수 있음.


사용방법

1. 작업 디렉토리의 파일을 복원: git restore <file>를 실행하면, 지정된 파일의 변경사항을 HEAD의 상태로 되돌림
    즉, 최근 커밋 상태로 해당 파일을 복원. 이 경우, 아직 커밋되지 않은 변경사항은 제거됨.

2. 스테이징한 파일 언스테이징하기: git restore --staged <file>을 실행하면, 지정된 파일의 인덱스(즉, 스테이징 영역) 상태를
    HEAD의 상태로 되돌림. 이 경우, 스테이징된 변경사항이 제거되지만, 작업 디렉토리의 변경사항은 그대로 유지됨.

# git restore --source

특정 커밋 또는 브랜치의 파일 상태로 현재 작업 디렉토리의 파일을 복원하는 데 사용

--source 옵션 뒤에는 원하는 커밋의 해시 값이나 브랜치 이름을 지정할 수 있음
이 명령어는 복원하려는 파일을 커밋 또는 브랜치의 상태로 바꾸는 것으로, 아직 커밋되지 않은 변경사항이 사라짐.

ex) --source <comit-hash><file> 커밋해쉬의 상태로 파일을 복원 
    --sourcce <branch-name><file> 지정된 브랜치의 상태로 파일을 복원

    restore 명렁어는 되돌릴 수 없기에 사용 전 백업이나 신중하게 사용해야 함


__________________________________________________________________________________________________________________________


# git restore --satged
파일을 스테이징(staged) 상태(git add) 를 해제하는 데 도움이 된다.
git의 인덱스(스테이징)에서 파일을 제거하되, 작업 드렉토리의 변경 사항은 그대로 유지함


사용방법
git restore --staged <file> 명령어를 실행하면, 지정된 <file>의 스테이징 상태가 해제됨 
이는 git reset HEAD <file> 명령어와 동일한 동작을 수행함

- **실수로 스테이징한 파일을 언스테이징하고 싶은 경우**: `git restore --staged <file>` 명령어를 사용하면,
  실수로 스테이징한 파일을 언스테이징할 수 있음. 이렇게 하면 해당 파일의 변경사항은 다음 커밋에 포함되지 않음.
  
- **특정 파일의 변경사항만 커밋하고 싶은 경우**: 여러 파일의 변경사항 중 특정 파일의 변경사항만 커밋하고 싶다면,
-  `git restore --staged` 명령어를 사용하여 다른 파일들의 스테이징 상태를 해제할 수 있음.

___________________________________________________________________________________________________________________________

# git reset
커밋 삭제용 (혼자 작업 시 용이함 공동작업 사용 x)

git reset --mixed ( 기본값 )

커밋은 취소 되며 작업내용은 저장되며 add는 취소됨

git reset --soft

커밋 취소되며 작업내용은 저장되며 add는 저장됨

git reset --hard~번호

커밋,작업내용,add 까지 다 취소됨
ex) git reset --hard head ~번호 제외 시 현재 커밋 초기화

git reset --hard ORIG_HEAD

직전 취소된 리셋만 복구 가능
________________________________________________________________________________________________________________________

# git revert

협업 환경에서 사용.
특정 커밋의 변경사항을 "새로운 커밋"으로 되돌림.
기존 기록 보존, 안전하게 취소 가능.
(공동 작업용 github에 올라가는 순간 revert 사용)














