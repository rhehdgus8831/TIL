### JVM 메모리 구조
* **Methed Area** : class 정보, static 변수 저장 **(프로그램 시작부터 끝까지 유지)**
* **Heap** :  `new`로 생성된 객체 저장, GC(가바지 켈렉션)의 대상
* **Stack** : 메서드 호출 시 생성되는 지역, 매개 변수 저장 **(메서드 종료 시 소멸)**

### `String`,`StringBuilder`,`StringBuffer` 차이점
* `String` : 불변
* `StringBuilder` : 가변, 싱글스레드. 동기화 X, 속도 빠름
* `StringBuffer` : 가변 , 멀티스레드 , 동기화 지원 `Theaed-safe`

### 객체 지향 4대 특징
* **캡슐화** : 데이터와 기능을 묶어 외부 접근 허용
* **상속**: 부모 클래스를 상속 받아 사용
* **다형성**: 하나의 객체를 여러 형태로 가질 수 있음
* **추상화**: 핵심만 추려내는 것

### Java 접근제어자 4가지
* `Public` : 모든 곳 접근 가능
* `Proteted` : 같은 패키지 + 상속받은 클래스
* `Default` : 같은 패키지
* `Pirvate`: 같은 클래스 내부

### 인테페이스(Interface)와 추상 클래스(Abstract Class)의 차이점

추상클래스는 **기능 확장**이 목적이며 단일 상속만 가능<br>
인테페이스는 **기능 강제 구현**이 목적이며 다중 상속 가능

### `static` 키워드는 메모리의 어느 영역에 저장되며, 언제 소멸하는지

**Methed Area**에 저장, 프로그램이 시작할때 로드되어 프로그램 종료될 때 소멸<br>
**인스턴트 생성 없이 클래스명으로 바로 접근 가능**


### `final` 키워드가 클래스,메서드,변수에 붙을 때 어떤 의미를 가지는지
* **변수** : 값 변경 불가 (상수)
* **메서드** : 오버라이딩 불가
* **클래스** : 상속 불가

### Java 컬렉션 프레임 워크(`List`, `Set`, `Map`)의 특징

* `List` : 순서가 있고 중복 허용 (`ArrayList`, `LinkedList`)
* `Set` : 중복 불가 (`HashSet)
* `Map` : Key-Value 쌍으로 저장, Key는 중복 불가 (HashMap)

### 제네릭(Generic)을 사용하는 이유와 장점
클래스 내부에 사용할 데이터 타입을 외부에서 지정하여 타입 안정석을 높힘<br>
불필요한 형 변환 코드를 줄임

### 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이
오버로딩은 같은 이름 메서드를 매개변수만 다르게 확장
오버라이딩은 상속 받은 메서드를 재정의

### Java 8에서 추가된 주요 특징
람다 표현식으로 코드 간결, Steam API로 컬렉션 처리 간편, Optional를 통해 NullPointerException 방지 가능

### SOLID 원칙

* **Single Responsibility Principle (단일 책임 원칙)** : 클래스는 단 하나의 책임만 가져야함
* **Open/Closed Principle (개방-폐쇄 원칙)** : 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야함
* **Liskov Substitution Principle (리스코프 치환 원칙)** : 자식 클래스는 부모 클래스를 대체할 수 있어야함
* **Interface Segregation Principle (인터페이스 분리 원칙)** : 자신이 사용하지 않는 메서드에 의존하지 않아야함
* **Dependency Inversion Principle (의존성 역전 원칙)** : 구체화가 아닌 추상화에 의존해야함







