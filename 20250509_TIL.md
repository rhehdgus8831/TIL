# Git과 버전 관리 시스템(Version Control System)
git : Git은 소프트웨어 개발에서 사용되는 분산 버전 관리 시스템(Distributed Version Control System, DVCS)
Git의 주요 목표는 속도, 데이터 무결성, 그리고 분산 시스템의 지원



버전 관리 시스템(VCS) : 시간에 따라 문서나 소스 코드와 같은 정보의 변화를 기록하고, 특정 시점의 버전을 다시 불러올 수 있는 시스템
이러한 시스템을 통해 여러 개발자가 동시에 같은 프로젝트 작업이 가능함, 또한 이전 버전으로 돌아갈 수 있음, 오류 해결도 가능



# VCS 유형

1. 중앙 집중식 버전 관리 시스템 - 장점: 소규모 작업 시 편함 중앙에서 확인 가능
단점: 대규모 시 불편

2. 분산 버전 관리 시스템 -Git, Mercurial, Bazaar, Darcs 등이 있습니다. 이 시스템은 클라이언트가 서버의 파일을 '복제'함
   이렇게 함으로써 네트워크에 접근할 수 없는 상황에서도 개발을 계속할 수 있고, 복잡한 브랜치 작업이 가능 (최근 현업에 많이 쓰임)


# GIT의 중요성

버전관리 - 각각의 변경사향을 커밋(COMMIT) 이라는 단위로 저장. 언제든지 특정 시점 코드로 돌아갈 수 있다

협업도구 - 동시에 같은 프로젝트 작업 

코드 안정성 유지 - 오류가 발생 시 되돌아 갈 수 있음

코드 리뷰 및 추적 - 코드의 차이점 및 버그 찾기

배포 관리 - CI,CD 파이프라인과 함께 사용되어 효율적인 배포 가능



GIT HUB - GIT을 사용하는 프로젝트를 호스팅하는 웹 기반 서비스

GIT은 온라인 오프라인 사용이 가능하지만 HUB는 인터넷 연결이 필요함 GIT에서 만든 소스코드를 HUB에 저장 및
배포하여 공유할 수 있으며 동시에 백업 역할도 수행함




# GIT 사용하는 두가지 방법

CLI - 명렁어 기반 버전관리 (터미널)
GUI - 그래픽 기반 버전관리 툴 (소스트리, GitHub Desktop, Git Kraken 등)


# 처음 GIT을 깔면 

git config --gloval user.name "이름"
git config --gloval user.email "이메일"  (github 이름,이메일)


_______________________________________________________________________________________________________________________________________

# 기본 터미널 명령어

# pwd : 현재 위치한 디렉토리 경로 출력
pwd는 print working directory의 약어로 현재 내가 보고있는 폴더의 경로를 알려줌
참고로 ~ 은 루트 디렉토리라고 부르며 보통 사용자 계정 경로가 지정되어 있음

 
# ls : 현재 위치한 디렉토리 안에 있는 폴더와 파일 목록 보기
ls는 list의 약어로 현재 위치한 폴더 내부에 있는 하위폴더, 파일들의 정보가 출력


# ls -l :   ls 명령어 뒤에 -l (알파벳 엘) 옵션을 주면 권한같은 좀 더 자세한 정보가 표시


# ls -a :  -a 옵션을 주면 숨김폴더 및 파일의 정보가 추가로 출력

   
# cd : 폴더 이동하기
cd 명령어는 change directory의 약어로 폴더를 이동하고 싶을 때 사용
보통 ls 명령어로 하위 폴더를 확인한 후 사용

# cd .. :  cd 뒤에 .. 을 붙이면 상위 폴더로 이동


## cd + 탭키 : cd 명령어 뒤에 탭키를 누르면 이동할 수 있는 목록이 출력 (ls명령어 없이 하위 폴더 목록을 확인할 수 있어 유용)


## cd + 일정부분 입력 후 탭키 : cd 명령어 입력 후 특정 알파벳을 입력후 탭키를 누르면 해당 알파벳으로 시작하는 목록만 출력
## 만약 특정 알파벳으로 시작하는 폴더가 단 1개라면 자동완성으로 단어가 완성됩니다.


# clear: 현재 터미널 출력 내용 깨끗하게 지우기
화면에 출력내용이 많아 지저분할 때 사용하면 화면이 초기화됩니다.


# start  .  : 현재 위치한 폴더를 엽니다.    - for Windows
# notepad: 텍스트 파일을 열어서 수정할 때 사용하는 기본 에디터


# open  .  :  현재 위치한 폴더를 엽니다.  - for MacOS


# mkdir 파일명 : 폴더 생성하기
mkdir은 make directory의 약어로 폴더를 생성하는 명령어입니다.


# mkdir -pv :  -pv옵션은 중첩구조로 폴더를 생성할 수 있게합니다.

# touch :  파일 생성하기

# rm 파일명 : 파일 삭제하기

# rm -rf  폴더명: 폴더 삭제하기 (주의!! - 폴더 안에 모든 내용까지 함께 삭제됨)

_______________________________________________________________________________________________________________________________________


# Git Basic


Git Repository : it에 의해 관리되는 프로젝트 디렉터리
이 레포지토리 안에는 프로젝트의 모든 파일과 각 파일의 수정 이력을 담은 정보가 포함되어 있음
레포지토리를 통해 Git은 프로젝트의 상태를 특정 시점으로 되돌릴 수 있거나, 변경 이력을 조회하거나,
다른 브랜치로 전환하는 등의 작업을 수행함.

Git Repository 주요 요소

1. **Working Directory**: 현재 작업 중인 프로젝트의 파일들이 위치하는 디렉토리
   
2. **Staging Area (Index)**: 커밋하기 위해 선택한 파일들의 정보를 저장하는 영역
    이 영역을 통해 원하는 파일들만을 커밋에 포함시킬 수 있음

3. **.git Directory (Repository)**: Git의 메타데이터와 객체 데이터베이스를 저장하는 디렉토리
    이 디렉토리를 복사하면 프로젝트의 모든 버전 정보와 히스토리를 복사하는 것과 같음


레포 지토리 유형

로컬 레포지토리: 나 혼자 하는 거

원격 레포지토리 : 협업

_______________________________________________________________________________________________________________________________________
로컬 레포지토리 생성하기

# git init
Git 레포지토리를 초기화하거나 새로운 Git 레포지토리를 생성하는데 사용되는 명령어

**사용법**

git init은 현재 작업 중인 디렉터리에 새로운 git 레포지토리를 생성함
git init을 실행하면 현재 디렉터리에 ".git"이라는 하위 디렉터리가 생성
이 디렉터리는 레포지토리의 모든 메타데이터를 담고 있음

git init 명령어를 실행하면, 새로운 Git 레포지토리가 생성되지만 아직 버전 관리가 이루어지는 파일은 없음
버전 관리를 시작하려면, 먼저 파일을 생성하거나 수정한 후 git add 명령어를 사용하여 변경사항을 스테이징 영역에 추가하고,
git commit 명령어를 사용하여 변경사항을 레포지토리에 저장해야 함
  

# .git 폴더

**HEAD**: 현재 체크아웃된 커밋을 가리킵니다.

**config**: 레포지토리 설정을 저장하는 파일입니다. 이 파일에는 사용자 정보,
원격 레포지토리의 URL, 그 외의 레포지토리 관련 설정이 저장됩니다.

**description**: 레포지토리에 대한 설명을 저장하는 파일입니다.
Git 웹 인터페이스에서 이 파일의 내용을 레포지토리 설명으로 사용하지만,
일반적으로 로컬 레포지토리에서는 이 파일이 사용되지 않습니다.

**hooks**: Git 훅(hook) 스크립트를 저장하는 디렉토리입니다.
이 스크립트들은 특정 Git 이벤트가 발생할 때 실행됩니다.

**info**: 전역 .gitignore 파일 등의 일반적인 정보를 저장하는 디렉토리입니다.

**objects**: 모든 데이터(커밋, 트리, 블롭 등)를 저장하는 디렉토리입니다.
  
 **refs**: 브랜치와 태그에 대한 참조(reference)를 저장하는 디렉토리입니다.


디렉토리는 프로젝트의 모든 이력 정보를 담고 있기 때문에, 
이 디렉토리를 복사하면 프로젝트의 모든 버전 정보와 히스토리를 복사하는 것과 같습니다.

!! 하지만 이 디렉토리는 직접 수정하거나 변경하는 것이 아니라 Git 명령어를 통해 관리해야 합니다.
그렇지 않으면 레포지토리가 손상될 수 있습니다.

   
# 초보자 주의사항

1. git init 명령어는 버전관리를 시작할 때 최초 1번만 입력!
- 이미 버전관리가 시작된 폴더를 다시 init하는 실수 x

1. git init을 하면 .git 폴더가 생성되는데 이 폴더 지우기 금지 !
- .git폴더가 삭제되면 그동안 버전관리했던 이력이 모두 소실됨
- 그래서 안전을 위해 숨김처리가 되어있음 ( .으로 시작하는 폴더는 중요폴더이기에 조심)

1. git init을 했던 폴더의 하위 폴더에 또 다시 git init을 하지 마세요!!
- git init을 하면 .git이 생기고 이것은 하위 폴더까지 전부 버전관리를 하겠다는 의미.
- 하위폴더에서 또다시 git init 명령어로 .git폴더를 생성하면 중첩으로 인해 문제가 발생.
- 실수로 하위 폴더에서 git init을 실행했다면 .git 폴더를 rm -rf 명령어로 삭제해주세요.

1. github와 같은 원격 저장소에서 clone한 저장소에는 git init을 실행 x 
- 원격저장소에서 내려받은 폴더는 기본적으로 버전관리가 되고 있는 상태입니다.
- 또 다시 init을 할 필요가 없습니다.

_______________________________________________________________________________________________________________________________________

# git 명령어


# git status 
Git 레포지토리의 상태를 확인하는데 사용되는 명령어. 이 명령어를 통해 어떤 파일이 수정되었는지, 
어떤 파일이 아직 스테이징되지 않았는지, 현재 어떤 브랜치에 위치해 있는지 등의 정보를 확인함.

출력되는 정보

1. 현재 체크아웃된 브랜치 이름
2. 스테이징 영역에 추가된 파일들 (Changes to be committed)
3. 스테이징 영역에 추가되지 않은 수정된 파일들 (Changes not staged for commit)
4. Git에 의해 추적되지 않는 새로운 파일들 (Untracked files)

특징 - git status 명령어는 "safe" 명령어로 간주됩니다.
즉, 이 명령어는 레포지토리에 어떠한 변경도 가하지 않고, 오직 정보만을 제공.
따라서 언제든지 안전하게 사용할 수 있음. ( 이상하다 싶거나 잘 모르겠으면 사용하는 것도 방법)

요약 - `git status` 명령어는 Git 사용자에게 현재 레포지토리의 상태에 대한 중요한 정보를 제공함.
이 명령어를 사용하면 현재 어떤 파일이 수정되었는지, 어떤 파일이 스테이징 영역에 있는지,
현재 어떤 브랜치에 있는지 등의 정보를 쉽게 파악할 수 있음.
이는 코드의 버전 관리를 더욱 효율적으로 진행할 수 있게 도움.

# git에서 버전을 생성하는 흐름: add, commit

Git에서 소스코드의 변경사항을 추적하고 새로운 버전을 생성하는 기본적인 흐름은 git add와 git commit 명령어를 사용.

# git add    ex) git add <filename>

변경된 파일들을 스테이징 영역(또는 인덱스)에 추가하는데 사용
이렇게 스테이징 영역에 추가된 파일들은 다음 커밋에 포함될 준비가 된 것으로 간주


또현재 디렉터리의 모든 변경사항을 스테이징 영역에 추가하려면 #git add. 실행할 수 있습니다.

# git commit    ex) git commit -m "Your commit message"

스테이징 영역에 추가된 변경사항들을 실제로 레포지토리에 저장(커밋)하는데 사용
커밋을 생성할 때는 해당 변경사항에 대한 설명을 담은 커밋 메시지를 함께 작성해야 함
(commit까지만 쓰면 VSCODE가 열림 한줄만 쓸게 아니고 메시지와 세부 내용도 쓰고 싶을 경우 사용)

순서 git add - git comit 순으로 작업 진행해야함 중간중간 git status로 작업 상황 확인



## Working Tree, Staging Area, Repository의 구조

**Working Tree (작업 트리)**: 이곳은 실제로 파일을 수정하는 작업 공간
즉, 파일을 생성, 수정, 삭제하는 모든 작업이 이루어지는 공간

**Staging Area (스테이징 영역 또는 인덱스)**: `git add` 명령어를 사용해 변경된 파일들이 먼저 추가되는 임시 저장 공간
이곳에 추가된 변경사항들은 다음 `git commit` 명령어 실행 시 레포지토리에 저장됨

**Repository (레포지토리)**: `git commit` 명령어가 실행되면, 스테이징 영역에 있는 변경사항들이 레포지토리에 저장
레포지토리는 프로젝트의 모든 버전과 이력 정보를 저장하는 공간으로, `.git` 디렉토리 안에 위치함


이 세 가지 영역은 Git의 핵심적인 부분으로서, Git의 버전 관리 시스템에서 중요한 역할을 수행
이들을 통해, 개발자는 소스코드의 변경사항을 효과적으로 관리하고 특정 시점의 버전으로 쉽게 되돌아갈 수 있음.

_______________________________________________________________________________________________________________________________________


# Atomic Commit

작지만 완전한 하나의 기능을 포함하는 커밋을 뜻함
최소 변경 사항만 담아야함을 의미 ( commit은 자주할수록 오류가 났을때 돌아갈 곳이 많다.
또한 누구나 알아보기 싶게 커밋해야 협업 시 알잘딱깔센으로 업무 처리 가능)


# 좋은 커밋 메세지 작성 요령

제목과 본문 분리

제목은 간결하고 명확하게

제목 줄에 명령문 사용하기 ex) a"Add feature" not "Added feature" or "Adds feature"

본문에는 무엇을 왜 바꿨는지 설명

본문은 72자 정도로 간결하게

이슈 트래커 id 참조 (커밋과 이슈 사이 관계를 명확하게 해결 가능)


_______________________________________________________________________________________________________________________________________

# 직전 커밋 수정 방법

# git commit --amend 
아래의 명령어를 실행하면, 커밋 메시지를 수정할 수 있는 텍스트 에디터가 열립니다.
기존의 커밋 메시지가 표시되므로, 이를 수정한 후 저장하고 에디터를 닫으면 커밋 메시지가 변경.

!!!! 주의사항 - 현재 브랜치 커밋 이력을 변경하기에 기존 커밋을 잃게 됨 혼자 작업시 괜찮지만
협업을 한다면 코드가 바꿔버려 혼선이 생기기에 주의해야함. !!!

_______________________________________________________________________________________________________________________________________

# git log --oneline --all --graph

로그 조회 코드 

_______________________________________________________________________________________________________________________________________


# gitignore 파일

Git에서 특정 파일이나 디렉토리를 버전 관리에서 제외하는 데 사용
이 파일은 프로젝트의 루트 디렉토리에 위치하며, 각 줄에는 버전 관리에서 제외할 파일 패턴을 지정할 수 있음

- 파일된 바이너리 파일이나 다른 중간 아티팩트를 버전 관리에서 제외하고 싶을 때
- 특정 개발자의 개발 환경에만 특정한 설정 파일을 버전 관리에서 제외하고 싶을 때
- 로그 파일, 캐시, 개인 정보 등을 버전 관리에서 제외하고 싶을 때

# 사용방법

`.gitignore` 파일에서 사용할 수 있는 패턴 몇 가지는 다음과 같습니다:

- `*.log`: 모든 .log 파일을 무시합니다.
- 
- `!important.log`: .gitignore 파일에서 더 나중에 나오는 패턴이 더 우선순위가 높으므로,
-  `!important.log` 패턴은 important.log라는 이름의 파일은 무시하지 않도록 예외를 설정합니다.
-  
- `/tmp`: 상대 경로로 시작하므로 프로젝트의 루트 디렉토리에 있는 tmp 디렉토리만 무시합니다.
- 
- `debug/`: debug라는 이름의 디렉토리를 무시합니다.
- 
- `doc/*.txt`: doc 디렉토리에 있는 .txt 파일을 무시합니다.

# 주의사항

.gitignore 파일은 이미 커밋된 파일에는 영향을 미치지 않습니다.
예를 들어, .gitignore 파일에 `*.log`를 추가하여 .log 파일을 무시하도록 설정했다고 해도,
이전에 이미 커밋된 .log 파일은 버전 관리에서 제외되지 않습니다.

이미 커밋된 파일을 .gitignore 파일에 추가한 경우에는 해당 파일을 수동으로 삭제하거나
`git rm --cached <file>` 명령어를 사용하여 Git의 캐시에서 삭제해야 합니다.
이후로는 .gitignore 파일에 지정한 대로 해당 파일이 무시됩니다.

## 참고

Github은 여러 프로그래밍 언어와 프레임워크, 운영체제 등을 위한 .gitignore 템플릿을 제공하고 있습니다.
이 템플릿들은 [GitHub의 gitignore 레포지토리](https://github.com/github/gitignore)에서 확인하실 수 있습니다.


_______________________________________________________________________________________________________________________________________


# 브랜치(Branch)란?
Git에서 브랜치는 코드의 특정 버전을 가리키는 포인터입니다. 
주로 main 브랜치가 기본 브랜치로 사용되며, 여러 기능을 동시에 개발하거나 버그 수정 시 활용됩니다.

브랜치의 필요성
 
병렬 개발: 여러 사람이 독립적으로 작업 가능.

버전 관리: 특정 시점으로 쉽게 되돌아갈 수 있음.

안정성: main 브랜치는 안정적 버전을 유지하고, 새 기능은 별도 브랜치에서 개발.

병합 관리: 충돌을 줄이고 병합 과정이 더 쉬워짐.

_______________________________________________________________________________________________________________________________________

# master' 또는 'main' 브랜치란?

Git에서 프로젝트의 기본 브랜치로, 코드의 안정적 버전을 관리하는 공간

최근에는 'master' 대신 'main' 브랜치를 기본으로 사용하는 추세

주요 용도

안정성 유지: 새로운 기능은 별도의 브랜치에서 개발하고, 검증 후 main 브랜치에 병합

배포 준비: 항상 안정적이므로 언제든지 배포가 가능하도록 관리

브랜치 관리 중요성
안정적인 코드를 유지하여 협업과 배포가 용이

효율적인 브랜치 관리로 프로젝트의 안정성을 확보할 수 있음음

# Git 프로젝트의 핵심은 'main' 브랜치를 항상 안정적으로 유지하는 것입니다


_______________________________________________________________________________________________________________________________________

# HEAD란?
Git에서 현재 작업 중인 커밋을 가리키는 포인터입니다.

기본적으로 가장 최근의 커밋을 가리키며, "Git이 어디를 바라보고 있는지"를 나타냄

주요 기능
커밋 표시: 현재 체크아웃된 커밋을 식별.
커밋 생성: 새로운 커밋이 생기면 HEAD가 자동으로 그 커밋을 가리킴.
커밋 탐색: HEAD~1: 이전 커밋  HEAD~2: 두 단계 전 커밋


Git의 HEAD는 현재 작업 중인 커밋을 나타내며, 커밋 위치를 추적하고 탐색하는 데 유용


_______________________________________________________________________________________________________________________________________


# branch 코드


## 브랜치 생성하기 : git branch <branch-name>

- `git branch <branch-name>` 명령어를 통해 새로운 브랜치를 만들어 별개의 작업을 진행


## 브랜치 이동하기 : git switch <branch-name>

- `git switch <branch-name>` 명령어를 통해 원하는 브랜치로 자유롭게 이동할 수 있음
- 이 때 HEAD 포인터가 이동한 브랜치의 최신 커밋으로 이동



## 새로운 브랜치를 생성하면서 즉시 이동하기 : git switch -c <branch-name>

- 위 명령어는 `git branch <branch-name>` 과 `git switch <branch-name>` 을 한번에 처리하는 명령어
- 자주 쓰이니 꼭 기억해두세요!!



_______________________________________________________________________________________________________________________________________

# Git의 checkout과 switch


# checkout 명령어
기능: 브랜치 전환, 특정 커밋으로 되돌리기, 파일 상태 복구 등 다양한 작업을 수행.

예시:  git checkout feature   # 브랜치 전환
git checkout HEAD~1    # 이전 커밋으로 되돌리기


# switch 명령어
기능: 브랜치 전환 전용 명령어로, Git 2.23부터 도입됨.

예시: git switch feature

# 차이점
checkout: 다목적(브랜치 전환, 커밋 되돌리기 등)
switch: 브랜치 전환 전용으로 더 직관적임

목적: 명령어를 구분하여 초보자의 혼란을 줄이기 위함
switch를 사용하면 브랜치 전환에 집중할 수 있어 더 명확

_____________________________________________________________________________________________________________________________________

# Git에서 브랜치 삭제


# git branch -d branch_name  로컬 브랜치 삭제 
일반 삭제 (병합된 경우)


# git branch -D branch_name 강제 삭제 (병합되지 않은 경우)


# git push origin --delete branch_name 원격 브랜치 삭제
원격 저장소의 브랜치를 삭제할 때 사용


_____________________________________________________________________________________________________________________________________

# Git에서 브랜치 이름 변경 요약

# git branch -m new_branch_name
 현재 브랜치 이름 변경

# git branch -m old_branch_name new_branch_name
 다른 브랜치 이름 변경

# git branch -m old_branch_name new_branch_name
로컬에서 이름 변경

# git push origin :old_branch_name
원격 브랜치 삭제

# git push origin new_branch_name
새 이름으로 원격에 푸시


_____________________________________________________________________________________________________________________________________

# Git 브랜치 실수 요약

1. 브랜치 전환 시 변경 사항 커밋 또는 스태시(stash) 안하기
   
문제: 수정 사항을 커밋/스태시하지 않고 브랜치를 전환하여 변경 사항이 엉키는 경우가 많음.
해결: 전환 전 항상 커밋 또는 스태시하기.

2. 긴 생명주기의 브랜치 사용
   
문제: 작업이 끝난 브랜치를 계속 사용하여 혼란을 초래.
해결: 작업 완료 후 병합하고 삭제하여 깔끔하게 관리.

3. main/master 브랜치에서 직접 작업하기
   
문제: 안정적 버전인 main에서 직접 작업하여 코드가 깨질 위험.
해결: 새 브랜치를 생성하여 작업하고, 완료 후 병합하기.

4. 하나의 커밋에 너무 많은 변경 포함
문제: 커밋 단위가 커서 나중에 디버깅이나 코드 리뷰가 어려움.
해결: 기능별로 작은 커밋을 만들어 논리적 구분 명확히 하기.

✅ 정리
Git 브랜치를 다룰 때는 작업 전 커밋/스태시, 완료 후 브랜치 삭제,
새 브랜치에서 작업, 작은 커밋을 습관화!





 
