
# **자바 람다(Lambda) 및 제네릭(Generic) 요약 정리**
오늘은 메서드에 코드 블록(동작) 자체를 전달하는 **람다 표현식**과, 다양한 타입의 데이터를 처리할 수 있게 해주는 **제네릭**에 대해 학습했다. 이 둘을 조합하여 매우 유연하고 재사용성 높은 필터링 기능을 만드는 과정을 단계별로 익혔다.

-----

## **1. 람다(Lambda)란 무엇일까?**

람다는 간단히 말해 \*\*이름이 없는 함수(Anonymous Function)\*\*다. 우리가 메서드를 만드는 이유는 특정 기능을 수행하는 코드 뭉치를 정의하고 필요할 때마다 호출하기 위함이다. 람다는 이 "코드 뭉치" 자체를 변수에 저장하거나 다른 메서드의 인수로 직접 전달할 수 있게 해준다.

#### **함수형 인터페이스 (Functional Interface)**

람다를 사용하기 위한 필수 조건이다.

  * **추상 메서드가 단 하나만 존재하는 인터페이스**를 말한다.
  * 이 "단 하나의 메서드"가 바로 람다식이 구현할 대상이 된다.
  * `@FunctionalInterface` 어노테이션을 붙이면, 컴파일러가 추상 메서드가 하나뿐인지 검사해주어 실수를 방지할 수 있다.

<!-- end list -->

```java
// Pet.java
package chap2_7.lambda.basic;

// 함수형 인터페이스 - 람다를 사용할 수 있는지 체크하는 어노테이션
@FunctionalInterface
public interface Pet {

    // 이 인터페이스는 추상메서드가 딱 1개다.
    // 따라서 이 인터페이스는 람다 표현식을 통해 구현될 수 있다.
    void eat();
    
    // 만약 추상 메서드가 2개 이상이면 컴파일 에러가 발생한다.
    // void sleep(); 

    // default, static 메서드는 개수에 상관없이 포함될 수 있다.
    static void foo(){}
}
```

-----

### **2. 필터링 기능의 발전 과정 (동작 파라미터화)**

`FilterApple.java`의 코드를 통해, 요구사항이 변할 때 코드가 어떻게 진화하는지, 그리고 왜 람다가 필요한지 알아보자.

#### **Step 1. 고정된 조건으로 필터링 (`filterGreenApples`)**

가장 원시적인 방법. "녹색 사과만 필터링"이라는 요구사항에 맞춰 메서드를 만든다.

  * **문제점**: 만약 "빨간색 사과도 필터링해주세요" 라는 새로운 요구가 생기면, 비슷한 내용의 `filterRedApples` 메서드를 또 만들어야 한다. 비효율적이다.

<!-- end list -->

```java
// FilterApple.java
/**
 * @solution - try 1 : 사과바구니에서 녹색 사과들만 필터링해주세요
 * @problem - 만약에 다른 색깔의 사과를 필터링해야 한다면 이 메서드만으로는 불가능
 */
public static List<Apple> filterGreenApples(List<Apple> basket) {
    List<Apple> greenBasket = new ArrayList<>();
    for (Apple apple : basket) {
        if (apple.getColor() == Color.GREEN) {
            greenBasket.add(apple);
        }
    }
    return greenBasket;
}
```

#### **Step 2. 값(Value)을 파라미터화 (`filterApplesByColor`)**

"어떤 색"으로 필터링할지, 그 \*\*값(`Color`)\*\*을 파라미터로 받도록 개선했다.

  * **문제점**: 이제 어떤 색상이든 필터링이 가능하다. 하지만 "무게가 100 이상인 사과를 필터링해주세요" 라는 요구가 오면 어떻게 할까? 필터링의 기준이 '색상'이 아니라 '무게'로 바뀌었기 때문에 이 메서드로는 해결이 불가능하다.

<!-- end list -->

```java
// FilterApple.java
/**
 * @solution - try 2 : 색상을 파라미터화하여 원하는 컬러의 사과를 필터링
 * @problem - 만약 필터링 기준이 색상이 아니라 무게라면?
 */
public static List<Apple> filterApplesByColor(List<Apple> basket, Color color) {
    List<Apple> filteredBasket = new ArrayList<>();
    for (Apple apple : basket) {
        if (apple.getColor() == color) {
            filteredBasket.add(apple);
        }
    }
    return filteredBasket;
}
```

#### **Step 3. 동작(Behavior)을 파라미터화 (`filterApples`)**

**핵심적인 변화.** 필터링 기준이 되는 **동작(코드) 자체**를 파라미터로 받는다. 자바에서는 코드를 직접 전달할 수 없으므로, 그 코드를 담은 **객체**를 전달한다. 이때 "필터링 조건을 검사한다"는 동작의 규격서로 \*\*함수형 인터페이스(`ApplePredicate`)\*\*를 사용한다.

  * **장점**: 이제 `ApplePredicate` 인터페이스의 `test` 메서드만 다르게 구현하면, 색상, 무게 등 어떤 조건으로든 필터링이 가능해졌다. **무엇으로 필터링할지(값)가 아니라 어떻게 필터링할지(동작)를 주입**하는 방식이다.

<!-- end list -->

```java
// ApplePredicate.java - 필터링 동작에 대한 규격서
@FunctionalInterface
public interface ApplePredicate {
    boolean test(Apple apple);
}

// AppleWeightPredicate.java - '무게가 100 이상'이라는 동작을 구현한 클래스
public class AppleWeightPredicate implements ApplePredicate {
    @Override
    public boolean test(Apple apple) {
        return apple.getWeight() >= 100;
    }
}

// FilterApple.java
/**
 * @solution - try 3 : 동작(기능)을 추상화시켜 파라미터화 한다.
 */
public static List<Apple> filterApples(List<Apple> basket, ApplePredicate predicate) {
    List<Apple> filteredBasket = new ArrayList<>();
    for (Apple apple : basket) {
        // 전달받은 predicate 객체의 test 메서드를 호출하여 조건을 검사한다.
        if (predicate.test(apple)) {
            filteredBasket.add(apple);
        }
    }
    return filteredBasket;
}
```

#### **람다의 등장**

`AppleWeightPredicate`처럼 간단한 기능을 위해 매번 클래스 파일을 만드는 것은 번거롭다. 이럴 때 **익명 클래스**나, 더 간결한 **람다 표현식**을 사용한다.

```java
// Main.java
// 1. 클래스로 구현체 전달 (전통적인 방식)
List<Apple> weightGoe100 = filterApples(appleBasket, new AppleWeightPredicate());
System.out.println("weightGoe100 = " + weightGoe100);

// 2. 람다로 구현체 전달 (현대적인 방식)
// ApplePredicate의 test(Apple x) 메서드를 즉석에서 구현하여 전달
// (Apple x) -> { return x.getWeight() % 2 == 1; }
// 코드가 한 줄이면 { }와 return 생략 가능, 파라미터 타입도 추론 가능
List<Apple> oddWeightApples = filterApples(appleBasket, x -> x.getWeight() % 2 == 1);
System.out.println("oddWeightApples = " + oddWeightApples);
```

-----

## **3. 제네릭(Generic)으로 필터링 기능 완성하기**

`filterApples` 메서드는 오직 `Apple`만 필터링할 수 있다는 한계가 있다. 만약 숫자나 문자열 리스트를 필터링하려면? 이때 **제네릭**을 사용한다.

  * **`<T>`**: Type의 약자로, "어떤 타입이든 들어올 수 있다"는 의미의 **타입 파라미터**. `T`는 메서드가 호출될 때 실제 타입(e.g., `Apple`, `Integer`, `String`)으로 결정된다.
  * **`GenericPredicate<T>`**: `T` 타입 객체를 받아 `boolean`을 반환하는 제네릭 함수형 인터페이스.

<!-- end list -->

```java
// GenericPredicate.java - 모든 타입에 대한 필터링 규격서
@FunctionalInterface
public interface GenericPredicate<T> {
    boolean test(T t);
}

// FilterApple.java
/**
 * @solution - try 4 : 여러 객체들을 다양하게 필터링할 수 있도록 제네릭을 적용
 */
public static <T> List<T> filter(List<T> list, GenericPredicate<T> predicate) {
    List<T> filteredList = new ArrayList<>();
    for (T t : list) {
        if (predicate.test(t)) {
            filteredList.add(t);
        }
    }
    return filteredList;
}
```

### **제네릭 필터의 활용**

이제 `filter` 메서드 하나로 세상 모든 타입의 리스트를 필터링할 수 있게 되었다\!

```java
// Main.java
List<Integer> numbers = List.of(1,2,3,4,5,6);
// 짝수만 필터링
List<Integer> evenNumbers = filter(numbers, n -> n % 2 == 0);
System.out.println("evenNumbers = " + evenNumbers);

// 노란 사과만 필터링
List<Apple> yellowAppleList
        = filter(appleBasket, a -> a.getColor() == YELLOW);
System.out.println("yellowAppleList = " + yellowAppleList);

// 글자 길이가 3인 음식만 필터링
List<String> filteredFoods = filter(
        List.of("짜장면", "우동", "김", "탕수육"),
        str -> str.length() == 3
);
System.out.println("filteredFoods = " + filteredFoods);

```

### **람다 표현식, 어떻게 줄여나갈까? (문법 생략 규칙)**

람다는 개발자가 더 편하게 코드를 작성할 수 있도록 여러 가지 생략 규칙을 제공해요. 가장 긴 형태의 익명 클래스에서 시작해서, 어떤 부분이 어떻게 생략되어 최종적인 람다식이 되는지 단계별로 살펴볼게요.

\*\*`무게가 100 이상인 사과를 찾는다`\*\*는 간단한 기능을 예시로 들어보겠습니다.

-----

#### **Step 0. 시작점: 익명 클래스 (Anonymous Class)**

람다가 등장하기 전, 우리는 일회용 기능을 구현하기 위해 아래와 같이 이름 없는 클래스를 사용했어요. 가장 정석적이지만 가장 긴 형태죠.

```java
// 가장 긴 형태의 익명 클래스
ApplePredicate predicate = new ApplePredicate() {
    @Override
    public boolean test(Apple apple) {
        return apple.getWeight() > 100;
    }
};
```

-----

### **람다 표현식, 어떻게 줄여나갈까? (문법 생략 규칙)**

람다 표현식은 더 간결한 코드를 위해 여러 문법 생략 규칙을 제공한다. \*\*`무게가 100 이상인 사과를 찾는다`\*\*는 기능을 예시로, 가장 긴 형태인 익명 클래스에서 시작하여 어떻게 최종적인 람다식이 되는지 단계별로 정리했다.

#### **Step 0. 시작점: 익명 클래스 (Anonymous Class)**

람다 이전에는, 일회용 기능을 구현하기 위해 아래와 같이 이름 없는 클래스를 사용했다. 가장 정석적이지만 코드가 길다.

```java
// 가장 긴 형태의 익명 클래스
ApplePredicate predicate = new ApplePredicate() {
    @Override
    public boolean test(Apple apple) {
        return apple.getWeight() > 100;
    }
};
```

\<br\>

#### **Step 1. 람다로의 첫 변환**

람다는 함수형 인터페이스의 단 하나뿐인 추상 메서드를 구현하는 것이므로, `new ApplePredicate()`, `@Override`, 메서드 이름 `test` 등은 모두 불필요하다. 이 모든 것을 `->` 기호로 대체할 수 있다.

```java
// 람다의 기본 형태: (파라미터 목록) -> { 실행 코드 }
ApplePredicate predicate = (Apple apple) -> {
    return apple.getWeight() > 100;
};
```


#### **Step 2. 파라미터 타입 생략**

컴파일러는 문맥을 통해 `apple` 파라미터가 `Apple` 타입임을 추론할 수 있다. 따라서 파라미터의 타입을 생략할 수 있다.

```java
// 1. 파라미터의 타입을 생략
ApplePredicate predicate = (apple) -> {
    return apple.getWeight() > 100;
};
```



#### **Step 3. 파라미터 소괄호() 생략**

만약 파라미터가 하나뿐이라면, 그 파라미터를 감싸는 소괄호 `()`도 생략이 가능하다.

> (참고) 파라미터가 없거나(`() -> ...`) 두 개 이상일 때(`(n1, n2) -> ...`)는 소괄호를 생략할 수 없다.

```java
// 2. 파라미터가 하나일 경우 소괄호() 생략
ApplePredicate predicate = apple -> {
    return apple.getWeight() > 100;
};
```



#### **Step 4. 중괄호{}와 return 키워드 생략**

람다 바디의 실행 코드가 한 줄이라면, 중괄호 `{}`와 `return` 키워드도 생략할 수 있다. 이 경우 표현식의 결과가 자동으로 반환되어 가장 간결한 형태가 완성된다.

```java
// 3. 실행문이 한 줄일 경우 중괄호{}와 return 생략
ApplePredicate predicate = apple -> apple.getWeight() > 100;
```
