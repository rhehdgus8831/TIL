# Git Rebase

Git Rebase는 브랜치의 커밋을 다른 브랜치의 끝으로 옮기는 방법

## 장점

- 선형 히스토리: 히스토리가 단순하고 직관적
- 깊은 이해: 커밋 히스토리를 통해 흐름 파악 쉬움

## 단점

- 위험요소: 공개된 브랜치에서 rebase를 사용시 히스토리가 변경되어 혼란이 생길 수 있음
- 충돌: 여러 커밋에서 충돌이 발생할 수 있으며 순차적으로 해결해야함


### 공개 및 협업 중인 브랜치에서 사용 X (걍 쓰지마셈)

_____

# Git Interactive Rebase (git rebase -i )

## Interacyive Rebase란?

### 정의:
#### 커밋 히스토리를 세밀하게 수정,재정렬,합치기,삭제를 할 수 있는 명령어.


### 목적
#### 깔끔한 커밋 히스토리 유지 및 불필요한 커밋 정리용도 (실무 시 PR 전에 사용)


## 3. **커밋 리스트 구조**

- #### **형식**: ( code . 으로 봤을 때)
    
    ```
    pick 3f5e4c8 Add feature X
    pick 2d4f5c7 Fix bug Y
    pick b2d4e5f Improve documentation
    
    ```
    
- #### **기본 명령어 설명**
  
    - `pick`: 커밋을 그대로 유지
    - 
    - `reword`: 커밋 메시지를 수정
    - 
    - `edit`: 커밋 내용을 수정
    - 
    - `squash`: 커밋을 이전 커밋과 합침 (메시지 병합 가능)
    - 
    - `fixup`: 커밋을 이전 커밋과 합침 (메시지 무시)
    - 
    - `drop`: 커밋을 삭제
 

______


# Cherry-pick

## Git에서 특정 커밋을 골라서 현재 브랜치에 적용하는 기능입니다.

### 사용 상황

- 다른 브랜치의 버그 수정을 현재 브랜치에 적용할 때
- 특정 기능만 현재 버전에 추가하고 싶을 때
- 여러 커밋 중 필요한 것만 선택하고 싶을 때
- 다른 팀원의 특정 커밋만 적용하고 싶을 때


### 장점

- 필요한 변경사항만 선택적으로 적용 가능
- 다른 브랜치 내용을 모두 병합하지않고 특정 변경사항만 가져올 수 있음
- 다양한 브랜치에서 작업된 코드를 통합하는데 효과적


### 단점

- 동일한 변경사항에 대해 커밋 해시가 달라짐
- 여러 커밋을 체리 픽 하게되면 충돌 가능성 높음
- 팀 협업 시 커뮤니케이션 없이 사용하면 코드 중복이나 혼란 초래


## 기본 명렁어

### git cherry-pick <커밋 해시>

여러 커밋 해시를 한 번에 체리픽 가능
ex <커밋1> <커밋2>

### 충돌 발생 시

1. git status로 파일 확인
2. 수동으로 해결 ( 마크 지우기 )
3. 해결된 파일 저장 후 git add로 스테이징
4.  git cherry-pick --continue 명령으로 진행 (commit 대신 사용)
### 취소하고 싶으면 cherry-pick --abort

_____

# Git tag

## 특정 커밋을 참조하기 위한 고정된 포인터로, 주로 프로젝트의 특정 시점을 표시하는 데 사용

### 특징

- 브랜치와 달리 변하지 않음
- 특정 커밋을 영구적으로 기록함

### 사용 예

- 소프트웨어 릴리스 버전 관리 (예: v1.0, v2.0)

#### 코드 버전 관리와 릴리스 사이클을 효율적으로 관리 가능

____

# Semantic Versioning (시맨틱 버저닝)

## 줄여서 SemVer는 소프트웨어 버전을 체계적으로 관리하기 위한 버전 넘버링 규칙


### 0.0.0 (MAJOR.MINOR.PATCH)

- **MAJOR (주 버전):** 주요 변경 사항. 기존 API가 호환되지 않게 변경된 경우 이 숫자가 증가
   MAJOR 버전이 변경되면 사용자는 새 버전으로 업그레이드할 때 코드의 호환성을 확인해야함
  
- **MINOR (부 버전):** 기능 추가 기존
  API와 호환되면서 새로운 기능이 추가된 경우 이 숫자가 증가
  MINOR 버전이 증가하면 기존 기능은 그대로 유지되면서 새로운 기능이 추가되었다는 것을 의미
  
- **PATCH (수 버전):** 버그 수정이나 사소한 변경
  사항 기존 API와 완전히 호환되며,
  주로 오류를 수정하거나 미미한 개선 사항이 있을 때 이 숫자가 증가

### 예시

- **`1.0.0`**: 첫 번째 안정적인 릴리스.
- **`1.1.0`**: 새로운 기능이 추가되었지만, 기존 API와 호환
- **`1.1.1`**: 버그가 수정되었고, API는 그대로 유지
- **`2.0.0`**: 기존 API와 호환되지 않는 큰 변화가 발생


## Git tag 관련 명령

| 기능                      | 명령어                                                    | 설명                                                           |
| ----------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| Lightweight Tag 생성      | `git tag <tag_name>`                                   | 주어진 `<tag_name>`으로 lightweight 태그를 생성                   |
| Annotated Tag 생성        | `git tag -a <tag_name> -m "Tag message"`               | 주어진 `<tag_name>`으로 annotated 태그를 생성하고, 태그 메시지를 추가        |
| 이전 커밋에 태그 지정            | `git tag <tag_name> <commit_hash>`                     | 특정 커밋 `<commit_hash>`에 lightweight 태그를 지정               |
| 이전 커밋에 Annotated Tag 지정 | `git tag -a <tag_name> <commit_hash> -m "Tag message"` | 특정 커밋 `<commit_hash>`에 annotated 태그를 지정하고, 태그 메시지를 추가    |
| 태그 목록 조회                | `git tag`                                              | 현재 리포지토리에 있는 모든 태그를 나열합                               |
| 특정 패턴에 일치하는 태그 목록 조회    | `git tag -l "<pattern>"`                               | `<pattern>`에 일치하는 태그를 필터링하여 나열                           |
| 태그 세부 정보 확인             | `git show <tag_name>`                                  | 특정 태그 `<tag_name>`의 세부 정보를 보여줌                            |
| 로컬에서 태그 삭제              | `git tag -d <tag_name>`                                | 로컬 리포지토리에서 특정 태그 `<tag_name>`을 삭제                       |
| 원격 리포지토리에 태그 푸시         | `git push origin <tag_name>`                           | 특정 태그 `<tag_name>`을 원격 리포지토리에 푸시                         |
| 모든 태그 푸시                | `git push origin --tags`                               | 로컬 리포지토리의 모든 태그를 원격 리포지토리에 푸시                            |
| 태그로 체크아웃                | `git checkout <tag_name>`                              | 특정 태그 `<tag_name>`로 체크아웃하여 분리된 헤드(detached HEAD) 상태가 됨    |
| 태그를 기준으로 브랜치 생성         | `git checkout -b <new_branch_name> <tag_name>`         | 특정 태그 `<tag_name>`를 기준으로 새로운 브랜치 `<new_branch_name>`을 생성 |



# Git reflog

## 로컬 저장소의 모든 참조(브랜치 이동, 커밋, 머지 등) 이력을 기록하고 조회하는 명령어

### 특징

- Git은 모든 참조 업데이트(HEAD 이동)를 내부적으로 기록하며, git reflog를 통해 조회할 수 있음

- 로컬에서 발생한 대부분의 Git 작업(커밋, 리셋, 체리픽, 병합 등)을 추적할 수 있음

### 주요 기능 및 사용 상황:

- 과거 커밋 복구: 잘못된 리셋이나 삭제된 커밋을 복구할 때 사용

- 브랜치 위치 추적: 이전에 있던 브랜치나 커밋 위치를 확인할 때 유용

- HEAD 복구: 잘못된 리베이스나 리셋으로 이동된 HEAD 위치를 되돌릴 수 있음

- 커밋 히스토리 확인: git log에 기록되지 않은 최근 활동도 조회할 수 있음


## 한계점

## 로컬에서만 유효함

- 로컬 저장소 내역만 기록함 ( 내껏만 기록한다고 생가하면 됨 )

## 90일까지 저장

- 영구적이진 않음


## `reflog` 사용 시 유용한 상황

- **실수로 삭제된 커밋 복구**: 브랜치를 잘못 삭제하거나, 커밋을 실수로 리셋한 경우 `reflog`를 통해 커밋을 복구
- **최근 활동의 빠른 추적**: 로컬에서 발생한 Git 명령어의 기록을 확인하여 어떤 작업이 수행되었는지 추적
- - **HEAD 위치 추적**: HEAD가 최근에 가리켰던 커밋들을 추적하여 복구
 

## Reflog References의 구조와 개념

### 구조

브랜치나 HEAD가 어떤 커밋을 가리키고 있었는지 기록함
이때 reflog references는 이 기록된 참조를 의미하며, 이를 통해 쉽게 이전 커밋으로 돌아가거나 특정 커밋을 참조할 수 있음


### 형식

#### HEAD@{n}
- n번째 reflog 항목을 가리킵니다.
- 최근 참조부터 시작하여 0, 1, 2... 순으로 증가

#### branch_name@{n}
- 특정 브랜치의 n번째 reflog 항목을 가리킴

#### HEAD@{time}
- 시간 기반 참조
- 예: HEAD@{yesterday}는 어제 HEAD가 가리키던 커밋을 의미


### 사용 사례

#### 이전 커밋으로 되돌아가기
- 잘못된 리셋 후 HEAD@{1}과 같은 명령으로 한 단계 이전 상태로 복구할 수 있음
  
#### 특정 시점으로 이동
- 시간 기반 참조(예: HEAD@{3.days.ago})를 사용하여 특정 날짜의 상태로 되돌릴 수 있음

#### 이전 브랜치 위치 확인
- 특정 브랜치의 이전 위치를 확인할 때 사용합니다.
- 예: feature-branch@{2}는 해당 브랜치의 두 번째 이전 참조를 나타냄


## 주요 명령어 및 사용 예시

### HEAD를 이전 상태로 복원

#### git reset --hard HEAD@{1}
- 현재 HEAD를 reflog에서 1번째 이전 커밋으로 되돌림

### 특정 브랜치에서의 reflog 참조

#### git checkout feature-branch@{3}
- feature-branch 브랜치의 세 번째 이전 상태를 체크아웃함

### 특정 시간으로 이동

#### git reset --hard HEAD@{yesterday}
어제 시점으로 HEAD를 되돌림


## Timed References 구조와 사용법


### 기본 구조

- HEAD@{time} 형식으로 특정 시간에 HEAD가 가리키던 커밋을 참조할 수 있음
- 브랜치 이름과도 결합 가능: branch_name@{time}

### 주요 시간 표현

- HEAD@{5.minutes.ago}: 5분 전 커밋
- HEAD@{yesterday}: 어제 커밋
- HEAD@{2.weeks.ago}: 2주 전 커밋
- branch_name@{2023-08-01 14:00:00}: 특정 날짜 및 시간의 커밋

## 사용 시나리오

### 과거 상태로 되돌리기

- 잘못된 변경을 되돌리기 위해 HEAD@{time}을 사용하여 과거 상태 복구

### 브랜치 위치 확인

- 복잡한 브랜치 작업에서 특정 시점의 브랜치 상태를 확인할 때 유용

### 복구 작업

- 실수로 삭제된 커밋을 복구하거나 잘못 조작한 브랜치를 수정할 때 활용

## 결론

- Git reflog는 로컬 참조 이력을 추적하여 실수로 인한 데이터 손실을 방지하는 데 유용하지만, 로컬에서만 관리됨
- 일정 기간 후 삭제될 수 있으므로 중요한 데이터는 브랜치로 관리하거나 별도로 백업하는 것이 좋음
- reflog를 적절히 활용하면 Git 작업을 효율적으로 관리할 수 있음






