
# SQL 그룹 함수 & 윈도우 함수

## 1\. 고급 그룹 함수 (GROUP BY 확장)

`GROUP BY` 절을 확장하여 다양한 수준의 소계 및 총계를 생성하는 함수들입니다. `ROLLUP`, `CUBE`, `GROUPING SETS`를 사용하여 복잡한 집계 리포트를 하나의 쿼리로 만들 수 있습니다.

### ✨ `GROUPING()` 함수

`ROLLUP`이나 `CUBE`를 사용할 때, 특정 행이 소계 또는 총계인지 구분하기 위해 사용됩니다.

  * **`GROUPING(컬럼명)`**: 해당 컬럼이 집계에 사용되어 `NULL`로 표시되면 `1`을, 그렇지 않으면 `0`을 반환합니다.
  * 이 함수를 `CASE` 문과 함께 사용하면 집계 결과를 더 명확하게 표현할 수 있습니다.

<!-- end list -->

```sql
-- GROUPING() 함수를 사용해 집계 여부 확인
SELECT
    CASE WHEN GROUPING(user_id) = 1 THEN '전체 합계' ELSE TO_CHAR(user_id) END AS "사용자",
    CASE WHEN GROUPING(post_type) = 1 THEN '사용자 소계' ELSE post_type END AS "게시물 종류",
    SUM(view_count) AS "총 조회수"
FROM POSTS
GROUP BY ROLLUP(user_id, post_type)
ORDER BY user_id, post_type;
```



### `ROLLUP`

`ROLLUP`은 계층적인 소계를 생성합니다. 지정된 컬럼 순서대로 오른쪽 컬럼부터 집계를 제거하며 다차원적인 소계를 만듭니다.

  * `ROLLUP(A, B)`는 다음 세 가지 레벨의 집계를 생성합니다.
    1.  `A, B` 그룹별 집계
    2.  `A` 그룹별 소계
    3.  전체 총계

<!-- end list -->

```sql
-- user_id와 post_type을 기준으로 계층적 집계를 수행합니다.
SELECT
    user_id,
    post_type,
    SUM(view_count) AS total_views
FROM
    POSTS
GROUP BY
    ROLLUP(user_id, post_type) -- (user_id, post_type), (user_id), (전체) 순으로 집계
ORDER BY user_id, post_type;
```



### `CUBE`

`CUBE`는 지정된 컬럼들의 모든 가능한 조합에 대한 소계를 생성합니다.

  * `CUBE(A, B)`는 다음 네 가지 레벨의 집계를 생성합니다.
    1.  `A, B` 그룹별 집계
    2.  `A` 그룹별 소계
    3.  `B` 그룹별 소계
    4.  전체 총계

<!-- end list -->

```sql
SELECT
    CASE WHEN GROUPING(user_id) = 1 THEN '전체' ELSE TO_CHAR(user_id) END AS "사용자",
    CASE WHEN GROUPING(post_type) = 1 THEN '소계' ELSE post_type END AS "게시물 종류",
    SUM(view_count) AS "총 조회수"
FROM
    POSTS
GROUP BY
    CUBE(user_id, post_type); -- (user_id, post_type), (user_id), (post_type), (전체) 조합으로 집계
```



### `GROUPING SETS`

`GROUPING SETS`는 개발자가 필요로 하는 집계 조합만 명시적으로 지정할 수 있어 가장 유연합니다.

  * `GROUPING SETS(A, B)`: `A` 그룹별 소계와 `B` 그룹별 소계를 각각 생성합니다.
  * `GROUPING SETS((A, B), A, ())`: `ROLLUP(A, B)`와 동일한 결과를 반환합니다.
  * `GROUPING SETS((A, B), A, B, ())`: `CUBE(A, B)`와 동일한 결과를 반환합니다.

-----

## 2\. 윈도우 함수 (Window Functions)

윈도우 함수는 `GROUP BY`처럼 행을 그룹으로 묶어 집계하지 않고, 각 행에 대해 연관된 행들(윈도우)의 값을 계산합니다. `OVER()` 절과 함께 사용됩니다.

### ✨ 순위 함수 (Ranking Functions)

`OVER (ORDER BY ...)` 구문과 함께 쓰이며, 특정 기준에 따라 각 행의 순위를 매깁니다.

| 함수 | 설명 | 예시 (점수: 100, 90, 90, 80) |
| --- | --- | --- |
| `RANK()` | 일반적인 순위 함수. 공동 순위 다음은 해당 인원만큼 건너뛰고 순위를 매깁니다. | 1, 2, 2, 4 |
| `DENSE_RANK()` | 공동 순위가 있어도 순위를 건너뛰지 않고 연속적으로 매깁니다. | 1, 2, 2, 3 |
| `ROW_NUMBER()` | 순위와 상관없이 고유한 번호를 순차적으로 부여합니다. | 1, 2, 3, 4 |

```sql
SELECT
    employee_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num
FROM employees;
```



###  오프셋 함수 (Offset Functions)

현재 행을 기준으로 특정 거리만큼 떨어진 행의 값을 가져옵니다.

| 함수 | 설명 |
| --- | --- |
| `LAG(컬럼, N, 기본값)` | 현재 행보다 `N`번째 앞에 있는 행의 값을 가져옵니다. |
| `LEAD(컬럼, N, 기본값)` | 현재 행보다 `N`번째 뒤에 있는 행의 값을 가져옵니다. |

  * `N`과 `기본값`은 생략 가능하며, 생략 시 `N`은 1, `기본값`은 `NULL`이 됩니다.

<!-- end list -->

```sql
-- 각 직원의 급여와 바로 이전 순위 직원의 급여를 비교
SELECT
    employee_name,
    salary,
    LAG(salary, 1, 0) OVER (ORDER BY salary) AS previous_salary
FROM employees;
```
