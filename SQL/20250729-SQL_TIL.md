
# 서브쿼리(Subquery) 학습 노트

## 1. 서브쿼리(Subquery)란?

하나의 SQL 문 안에 포함된 또 다른 SQL 문을 의미합니다. 서브쿼리는 메인 쿼리가 실행되기 전에 한 번 실행되며, 서브쿼리의 결과 값을 메인 쿼리가 사용합니다. 주로 `WHERE` 절이나 `FROM`, `SELECT` 절에서 사용됩니다.

- **장점**: 쿼리 하나로 데이터를 조회할 수 있어 간결하고, 복잡한 로직을 단계적으로 구현할 수 있습니다.
- **주의**: 과도한 사용은 성능 저하의 원인이 될 수 있습니다. `JOIN`으로 대체 가능한 경우 성능을 비교해 보는 것이 좋습니다.

---

## 2. 단일 행 서브쿼리 (Single-Row Subquery)

서브쿼리의 실행 결과가 **오직 하나의 행(Row)**만 반환하는 경우를 말합니다. 결과가 2개 이상이면 오류가 발생하므로, 결과가 유일한 값이라고 보장될 때 사용합니다. 단일 행 비교 연산자(`=`, `<>`, `>`, `>=`, `<`, `<=`)와 함께 사용됩니다.

### 예제 1: 특정 사용자가 작성한 모든 게시물 조회

`'ryan'`이라는 사용자의 `USER_ID`를 서브쿼리로 먼저 조회하고, 그 `USER_ID`를 이용해 `POSTS` 테이블에서 게시물을 조회합니다.

```sql
-- 라이언이 작성한 모든 게시물을 조회
SELECT *
FROM POSTS
WHERE USER_ID = (
        -- 서브쿼리: 'ryan'의 USER_ID를 조회합니다.
        -- 이 쿼리의 결과는 반드시 0개 또는 1개여야 합니다. (2개 이상 나오면 오류 발생)
        SELECT USER_ID
        FROM USERS
        WHERE USERNAME = 'ryan'
);
````

### 예제 2: 평균 조회수보다 높은 게시물 조회

전체 게시물의 평균 조회수를 서브쿼리로 계산하고, 그 평균값보다 `VIEW_COUNT`가 높은 게시물만 필터링합니다.

```sql
-- 우리 피드 데이터에서 평균 조회수보다 높은 조회수를 가진 게시물 조회
SELECT *
FROM POSTS
WHERE VIEW_COUNT > (
        -- 서브쿼리: POSTS 테이블의 전체 평균 조회수를 계산합니다.
        SELECT AVG(VIEW_COUNT)
        FROM POSTS
        )
;
```

-----

## 3\. 다중 행 서브쿼리 (Multi-Row Subquery)

서브쿼리의 실행 결과가 \*\*여러 개의 행(Row)\*\*을 반환하는 경우입니다. 다중 행 비교 연산자(`IN`, `ANY`, `ALL`)와 함께 사용해야 합니다.

| 연산자 | 설명 |
| --- | --- |
| `IN` | 서브쿼리가 반환한 **결과 목록에 포함된** 값과 일치하는 모든 행을 찾습니다. (`OR` 조건과 유사) |
| `ANY` | 서브쿼리가 반환한 **결과 중 하나라도 만족하면** 참이 됩니다. |
| `ALL` | 서브쿼리가 반환한 **모든 결과를 만족하면** 참이 됩니다. |

### 예제 1: `IN` 연산자 사용

`manager_id`가 1인 '카카오 그룹' 소속 사용자들의 `user_id` 목록을 서브쿼리로 조회하고, 해당 목록에 포함된 사용자들이 작성한 모든 게시물을 조회합니다.

```sql
-- 카카오 그룹에 있는 사용자들이 작성한 모든 피드 조회
SELECT *
FROM POSTS
WHERE USER_ID IN ( -- 서브쿼리의 결과가 여러 행이므로 IN 연산자 사용
        -- 서브쿼리: manager_id가 1인 모든 사용자의 user_id를 조회합니다. (결과가 0개 이상)
        SELECT user_id
        FROM USERS
        WHERE manager_id = 1
    )
;
```

### 예제 2: `ANY` 연산자 사용

사용자별 평균 조회수 중 **어느 하나라도** 그보다 높은 조회수를 가진 게시물을 조회합니다. 즉, 가장 낮은 평균 조회수보다 높은 모든 게시물이 해당됩니다.

```sql
-- ANY는 서브쿼리의 결과 중 하나라도 만족하는 경우를 찾음
SELECT *
FROM POSTS
WHERE VIEW_COUNT > ANY (
    -- 서브쿼리: 사용자별 평균 조회수를 그룹으로 묶어 조회
    SELECT AVG(VIEW_COUNT)
    FROM POSTS
    GROUP BY USER_ID
)
;
```

### 예제 3: `ALL` 연산자 사용

사용자별 평균 조회수 **모두**보다 높은 조회수를 가진 게시물을 조회합니다. 즉, 가장 높은 평균 조회수보다도 높은 게시물만 해당됩니다.

```sql
-- ALL은 서브쿼리의 결과 중 모두 만족하는 경우를 찾음
SELECT *
FROM POSTS
WHERE VIEW_COUNT > ALL (
    -- 서브쿼리: 사용자별 평균 조회수를 그룹으로 묶어 조회
    SELECT AVG(VIEW_COUNT)
    FROM POSTS
    GROUP BY USER_ID
)
;
```

### ※ 서브쿼리 연산자 요약

| 구분 | 연산자 | 사용 가능 서브쿼리 |
| --- | --- | --- |
| **단일 행 연산자** | `=`, `<>`, `<`, `>`, `<=`, `>=` | 단일 행 서브쿼리 |
| **다중 행 연산자** | `IN`, `ANY`, `ALL` | 다중 행 서브쿼리 |

-----

## 4\. 중첩 서브쿼리 (Nested Subquery) 및 활용

서브쿼리 안에 또 다른 서브쿼리가 사용되는 구조입니다. 복잡한 조건을 단계적으로 해결할 때 유용합니다.

### 예제 1: 특정 해시태그가 포함된 게시물 조회

`#포켓몬` 해시태그가 달린 모든 게시물을 조회하는 과정입니다. 3단계의 중첩 서브쿼리가 사용되었습니다.

1.  `HASHTAGS` 테이블에서 `#포켓몬`의 `TAG_ID`를 찾습니다.
2.  찾은 `TAG_ID`를 이용해 `POST_TAGS` 테이블에서 관련 `POST_ID` 목록을 찾습니다.
3.  `POST_ID` 목록을 이용해 `POSTS` 테이블에서 최종 게시물 정보를 조회합니다.

<!-- end list -->

```sql
SELECT *
FROM POSTS
WHERE POST_ID IN ( -- 3. 최종적으로 게시물 ID 목록을 사용하여 게시물 정보를 조회
    SELECT POST_ID
    FROM POST_TAGS
    WHERE TAG_ID = ( -- 2. 태그 ID를 사용하여 게시물-태그 매핑 테이블에서 게시물 ID를 찾음
        SELECT TAG_ID
        FROM HASHTAGS
        WHERE TAG_NAME = '#포켓몬' -- 1. 먼저 해시태그 이름으로 태그 ID를 찾음
        )
    )
;
```

#### 심화: `JOIN`과 함께 사용하기

위 예제에 `JOIN`을 추가하여 작성자 이름까지 함께 조회할 수 있습니다. 서브쿼리는 `WHERE` 절의 조건으로, `JOIN`은 테이블 간의 관계를 연결하는 역할로 사용되었습니다.

```sql
SELECT P.*,
       U.USERNAME
FROM POSTS P
LEFT JOIN USERS U ON P.USER_ID = U.USER_ID
WHERE POST_ID IN (
    SELECT POST_ID
    FROM POST_TAGS
    WHERE TAG_ID = (
        SELECT TAG_ID
        FROM HASHTAGS
        WHERE TAG_NAME = '#포켓몬'
    )
)
;
```

### 예제 2: 특정 사용자의 게시물에 '좋아요'를 누른 사용자 조회

`'pikachu'`가 올린 게시물에 '좋아요'를 누른 모든 사용자의 이름을 조회하는 복잡한 예제입니다.

1.  `USERS` 테이블에서 `'pikachu'`의 `USER_ID`를 찾습니다.
2.  찾은 `USER_ID`로 `POSTS` 테이블에서 `'pikachu'`가 작성한 모든 `POST_ID` 목록을 조회합니다.
3.  이 `POST_ID` 목록을 `IN` 연산자와 함께 사용하여 `LIKES` 테이블에서 '좋아요'를 누른 `USER_ID`를 찾습니다.
4.  `JOIN`을 이용해 최종적으로 사용자들의 `USERNAME`을 조회합니다.

<!-- end list -->

```sql
SELECT U.USERNAME
FROM LIKES L
JOIN USERS U ON L.USER_ID = U.USER_ID -- 4. 좋아요를 누른 사용자의 이름을 얻기 위해 JOIN
WHERE L.POST_ID IN ( -- 3. 피카츄의 게시물 ID 목록에 포함된 좋아요 기록을 필터링
    SELECT POST_ID
    FROM POSTS
    WHERE USER_ID = ( -- 2. 피카츄의 게시물 ID 목록을 조회
        SELECT USER_ID
        FROM USERS
        WHERE USERNAME = 'pikachu' -- 1. 'pikachu'의 USER_ID를 조회
        )
    )
;
```
