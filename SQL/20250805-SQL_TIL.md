# SQL TCL & DCL 

## 3강. TCL (Transaction Control Language)

데이터의 무결성을 보장하고 안전한 변경을 위해 사용하는 '트랜잭션 제어어'에 대한 정리.

### Part 1. 안전한 데이터 변경을 위한 약속

#### 1. 트랜잭션 (Transaction) 이란? 'All or Nothing'

- **정의**: 더 이상 쪼갤 수 없는, 논리적인 작업의 최소 단위.
- **핵심 원칙**: 'All or Nothing'. 트랜잭션을 구성하는 모든 DML 작업이 전부 성공하거나, 하나라도 실패하면 전부 실패로 처리해야 함.
- **예시: 계좌 이체**
    1. A 계좌에서 10,000원 차감 (UPDATE)
    2. B 계좌에 10,000원 증가 (UPDATE)
    - 위 두 작업은 반드시 하나의 트랜잭션으로 묶여야 함. 1번만 성공하고 시스템이 멈추면 데이터 정합성이 깨지기 때문.
- **Oracle 기준 트랜잭션의 생명주기**
    - **시작**: 첫 DML(INSERT, UPDATE, DELETE) 문장이 실행될 때.
    - **종료**: `COMMIT` 또는 `ROLLBACK` 명령어를 만날 때.

#### 2. TCL 기본 명령어: `COMMIT` & `ROLLBACK`

- **`COMMIT`**: 현재 트랜잭션 내에서 수행된 모든 DML 작업의 결과를 데이터베이스에 **영구적으로 저장**하는 명령어. COMMIT 후에는 이전 상태로 쉽게 되돌릴 수 없다.
- **`ROLLBACK`**: 직전 `COMMIT` 이후에 수행된 모든 DML 작업의 결과를 **전부 취소**하고, 트랜잭션을 `COMMIT` 직후의 상태로 되돌리는 명령어.

| 명령어     | 사용법      | 설명                                                                   |
| ---------- | ----------- | ---------------------------------------------------------------------- |
| `COMMIT`   | `COMMIT;`   | 현재 트랜잭션의 모든 변경사항을 영구적으로 DB에 반영합니다.              |
| `ROLLBACK` | `ROLLBACK;` | 현재 트랜잭션의 모든 변경사항을 취소하고, 마지막 COMMIT 시점으로 복구합니다. |

#### 3. 시나리오로 이해하는 트랜잭션

**시나리오**: '김철수'(student_id=101) 학생이 5000 포인트를 사용해 'SQLD 정복하기'(course_id=1) 강좌를 신청.

```sql
-- DML #1: 김철수 학생의 포인트 5000점 차감
UPDATE STUDENTS
   SET point = point - 5000
 WHERE student_id = 101;

-- DML #2: 수강신청 기록 추가
INSERT INTO ENROLLMENTS (enrollment_id, student_id, course_id)
VALUES (201, 101, 1);
````

  - **상황 1: 모든 작업 성공**

      - 두 DML이 모두 성공했을 때, 변경사항을 최종 확정.

    <!-- end list -->

    ```sql
    COMMIT;
    -- 이 명령어를 실행하는 순간, 포인트 차감과 수강신청 기록이 DB에 영구적으로 저장됩니다.
    ```

  - **상황 2: 2번 작업(INSERT)에서 오류 발생**

      - UPDATE는 성공했으나 INSERT가 실패한 경우, 데이터 불일치를 막기 위해 모든 작업을 취소.

    <!-- end list -->

    ```sql
    ROLLBACK;
    -- 이 명령어를 실행하는 순간, 실패한 INSERT 작업은 물론,
    -- 이미 성공했던 UPDATE 작업까지 모두 취소되어 포인트가 원래대로 복구됩니다.
    ```

-----

### Part 2. 트랜잭션의 개념과 ACID

트랜잭션은 데이터의 무결성을 보장하기 위해 4가지 중요한 특성(ACID)을 가져야 한다.

| 특성             | 영문        | 설명                                                                 |
| ---------------- | ----------- | -------------------------------------------------------------------- |
| **원자성** | Atomicity   | 트랜잭션의 연산들은 모두 성공하거나, 모두 실패해야 한다. (All or Nothing) |
| **일관성** | Consistency | 트랜잭션이 완료된 후에도 데이터베이스는 일관된 상태를 유지해야 한다.     |
| **격리성/고립성** | Isolation   | 여러 트랜잭션이 동시에 수행될 때, 서로의 작업에 영향을 미치지 않아야 한다. |
| **지속성/영속성** | Durability  | 성공적으로 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장되어야 한다. |

#### ACID 실무 사례

  - **은행 계좌 이체**: 출금과 입금 연산을 하나의 트랜잭션으로 묶어 **원자성**을 보장하고, 트랜잭션 실행 전후의 총액이 변하지 않도록 **일관성**을 유지한다.
  - **영화 좌석 예매**: 좌석 선택, 결제, 예매 정보 등록을 하나의 트랜잭션으로 묶어 **원자성**을 보장하고, 락(Lock)을 통해 다른 사용자가 동시에 같은 좌석을 예매하지 못하도록 **일관성**과 **격리성**을 보장한다.

-----

### Part 3. 중간 저장과 자동 커밋의 비밀

#### 5\. `SAVEPOINT`: 게임처럼 중간 저장하기

  - **정의**: 긴 트랜잭션 내에서 특정 지점까지의 작업만 롤백할 수 있도록 '저장 지점'을 만드는 명령어.
  - `ROLLBACK`이 트랜잭션 전체를 취소한다면, `SAVEPOINT`는 특정 지점까지만 되돌릴 수 있어 유연한 제어가 가능하다.

| 명령어                  | 사용법                                | 설명                                                         |
| ----------------------- | ------------------------------------- | ------------------------------------------------------------ |
| `SAVEPOINT`             | `SAVEPOINT 저장지점이름;`             | 트랜잭션 내에 특정 이름의 저장 지점을 생성합니다.            |
| `ROLLBACK TO SAVEPOINT` | `ROLLBACK TO SAVEPOINT 저장지점이름;` | 명시된 저장 지점 이후에 수행된 모든 DML을 취소합니다. (저장 시점으로는 돌아감) |

**시나리오**: 이영희(student\_id=102) 학생이 강좌 3개를 신청하다 마지막 강좌를 잘못 신청함.

```sql
-- DML #1: 'SQLD 정복하기' 신청
INSERT INTO ENROLLMENTS (enrollment_id, student_id, course_id) VALUES (202, 102, 1);

-- DML #2: '데이터 분석 입문' 신청
INSERT INTO ENROLLMENTS (enrollment_id, student_id, course_id) VALUES (203, 102, 10);

-- 중간 저장! sp1이라는 이름의 저장 지점 생성
SAVEPOINT sp1;

-- DML #3: '알고리즘 마스터' 신청 (실수!)
INSERT INTO ENROLLMENTS (enroll_id, student_id, course_id) VALUES (204, 102, 5);

-- 아차, 실수했다! 마지막 작업만 취소하자!
-- sp1 저장 지점 이후의 작업(DML #3)만 롤백함
ROLLBACK TO SAVEPOINT sp1;

-- 이제 최종적으로 COMMIT을 하면, 'SQLD 정복하기'와 '데이터 분석 입문' 신청 기록만 저장됩니다.
COMMIT;
```

#### 6\. 자동 커밋 (Auto Commit) - SQLD 핵심 함정\!

> **Oracle의 철칙: DDL 명령어(`CREATE`, `ALTER`, `DROP`, `TRUNCATE`)가 실행되면, 그 직전에 자동으로 `COMMIT`이 실행된다.**

  - DML 작업을 수행하다가 `COMMIT` 없이 DDL을 실행하면, 이전의 DML 작업들이 의도치 않게 영구 저장된다.
  - **반드시 기억해야 할 SQLD 시험의 핵심 함정\!**

**함정 시나리오**: 관리자가 실수로 모든 강좌 수강료를 0원으로 변경 후, 롤백 전에 테스트 테이블을 생성함.

```sql
-- DML: 실수로 모든 강좌의 수강료를 0원으로 변경
UPDATE COURSES SET price = 0;

-- 이런! 모든 강좌가 무료가 되어버렸다!

-- DDL: 잠깐 테스트용 테이블을 하나 만들자.
-- 이 명령어가 실행되는 순간, 바로 위의 UPDATE문이 자동으로 COMMIT됨!
CREATE TABLE TEMP_TEST (id NUMBER);

-- 이제 실수를 되돌리기 위해 롤백을 시도한다.
ROLLBACK;

-- 결과: 롤백되지 않음. UPDATE가 이미 COMMIT되었기 때문에 모든 강좌의 가격은 영구적으로 0원이 됨.
```

-----

## 4강. DCL (Data Control Language)

### Part 1. 데이터베이스의 문지기

#### 1\. 권한의 두 종류: 시스템 권한 vs 객체 권한

| 구분     | 역할                                 | 비유                                           | 대표적인 권한                                        |
| :------- | :----------------------------------- | :--------------------------------------------- | :--------------------------------------------------- |
| **시스템 권한** | 데이터베이스 **시스템 자체**에 대한 권한   | 백화점 건물 **출입** 및 **매장 개설** 권한   | `CREATE SESSION`, `CREATE TABLE`, `CREATE USER`      |
| **객체 권한** | **특정 객체**(테이블, 뷰 등)에 대한 권한 | 특정 매장 **출입** 및 **물건 구매/조회** 권한 | `SELECT`, `INSERT`, `UPDATE`, `DELETE` on a specific table |

#### 2\. `GRANT`: 권한 부여하기 (출입증 발급)

**시나리오**: 신입 마케터 'MARKETER'에게 DB 접속 및 COURSES 테이블 조회 권한 부여.

```sql
-- Step 1. 사용자 생성 (DDL)
-- IDENTIFIED BY 뒤에는 비밀번호를 지정
CREATE USER MARKETER IDENTIFIED BY marketing123;

-- 참고: Oracle 12c 이후 버전에서 사용자 생성 시 'C##' 접두어가 없으면 오류가 발생할 수 있음.
-- 그럴 경우 아래 스크립트를 먼저 실행하여 규칙을 우회.
ALTER SESSION SET "_ORACLE_SCRIPT"=true;

-- Step 2. 시스템 권한 부여: 접속 권한 주기
-- 데이터베이스에 접속할 수 있는 가장 기본적인 권한을 부여
GRANT CREATE SESSION TO MARKETER;

-- Step 3. 객체 권한 부여: 테이블 조회 권한 주기
-- MARKETER 사용자가 'COURSES' 테이블을 조회(SELECT)할 수 있도록 허용
GRANT SELECT ON COURSES TO MARKETER;
```

#### 3\. 권한 위임하기: `WITH GRANT OPTION`

  - 자신이 받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 함께 부여하는 옵션.

<!-- end list -->

```sql
-- MARKETER에게 COURSES 조회 권한을 주면서, 그 권한을 남에게 줄 수 있는 권한까지 함께 부여
GRANT SELECT ON COURSES TO MARKETER WITH GRANT OPTION;

-- 이제 MARKETER는 DB에 접속해서 아래 쿼리를 통해 MKT_INTERN에게 권한 위임 가능
-- (MARKETER 계정으로 접속해서 실행해야 함)
GRANT SELECT ON COURSES TO MKT_INTERN;
```

#### 4\. `REVOKE`: 권한 회수하기 (출입증 회수)

  - `GRANT`로 부여했던 권한을 다시 회수하는 명령어.

<!-- end list -->

```sql
-- 객체 권한 회수
REVOKE SELECT ON COURSES FROM MARKETER;

-- 시스템 권한 회수
REVOKE CREATE SESSION FROM MARKETER;
```

> **💡 `WITH GRANT OPTION` 권한 회수 시 연쇄 효과**
> `MARKETER`의 권한이 `REVOKE`되면, `MARKETER`가 `MKT_INTERN`에게 위임했던 권한까지 **연쇄적으로 모두 회수된다.**

-----

### Part 2. 권한을 꾸러미로 관리하기, `ROLE`

#### 5\. `ROLE`: 권한 '꾸러미'

  - **정의**: 여러 개의 시스템/객체 권한을 담을 수 있는 '권한 묶음'. '직책'과 유사한 개념.
  - **장점**: 다수의 사용자에게 동일한 권한들을 부여하고 회수할 때, `ROLE` 하나만 제어하면 되므로 관리가 매우 효율적이다.

#### 6\. `ROLE`을 이용한 3단계 권한 관리

**시나리오**: 개발자들에게 필요한 공통 권한을 `DEV_ROLE`로 묶어 관리.

  - **Step 1. `CREATE ROLE`: '직책' 만들기**

    ```sql
    -- 'DEV_ROLE' 이라는 이름의 역할을 생성
    CREATE ROLE DEV_ROLE;
    ```

  - **Step 2. `GRANT ... TO ROLE`: '직책'에 권한들 넣어주기**

    ```sql
    -- 시스템 권한 담기
    GRANT CREATE SESSION, CREATE TABLE TO DEV_ROLE;

    -- 객체 권한 담기
    GRANT SELECT, INSERT, UPDATE, DELETE ON COURSES TO DEV_ROLE;
    GRANT SELECT, INSERT, UPDATE, DELETE ON STUDENTS TO DEV_ROLE;
    GRANT SELECT, INSERT, UPDATE, DELETE ON ENROLLMENTS TO DEV_ROLE;
    ```

  - **Step 3. `GRANT ROLE TO USER`: 사용자에게 '직책' 부여하기**

    ```sql
    -- 사용자 생성
    CREATE USER DEV01 IDENTIFIED BY developer1;

    -- DEV01 사용자에게 DEV_ROLE 역할을 통째로 부여
    GRANT DEV_ROLE TO DEV01;
    ```

  - **권한 회수**: `REVOKE DEV_ROLE FROM DEV01;` 한 줄이면 `DEV_ROLE`에 포함된 모든 권한이 한 번에 회수된다.

<!-- end list -->

```
```
