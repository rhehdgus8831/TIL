
# 서브쿼리 (Subquery)

오늘은 SQL의 강력한 기능 중 하나인 서브쿼리에 대해 학습했습니다. 특히 `FROM` 절과 `SELECT` 절에서 사용하는 서브쿼리와 `EXISTS` 연산자에 대해 집중적으로 정리합니다.

## 1. 인라인 뷰 (Inline View)

인라인 뷰는 `FROM` 절에서 사용되는 서브쿼리입니다. 서브쿼리의 실행 결과가 마치 하나의 테이블(뷰)처럼 작동하여, 해당 결과를 다른 테이블과 `JOIN` 하거나 추가적인 조건을 적용할 때 유용합니다.

### 개념 정리

-   **동작 방식**: `FROM` 절의 서브쿼리가 먼저 실행되어 임시 데이터 집합(가상 테이블)을 생성합니다.
-   **별칭 (Alias)**: 생성된 임시 테이블은 반드시 별칭을 가져야 합니다.
-   **활용**: 복잡한 집계 데이터를 미리 계산하고, 이를 다른 테이블과 연결하여 최종 결과를 도출할 때 주로 사용됩니다.

---

### 예제 1: 사용자별 피드 작성 개수 조회

`POSTS` 테이블에서 사용자별 게시글 수를 먼저 계산한 후(`PC`), 그 결과를 `USERS` 테이블과 조인하여 사용자 이름과 함께 출력합니다.

**방법 A: 인라인 뷰를 먼저 명시**

```sql
-- 인라인 뷰(PC)를 먼저 FROM 절에 명시하고 USERS 테이블과 조인
SELECT
    PC.USER_ID,
    U.USERNAME,
    PC.POST_COUNT
FROM (
    -- 1. 사용자 ID별로 게시글 수를 센다 (이 부분이 인라인 뷰)
    SELECT USER_ID, COUNT(*) AS POST_COUNT
    FROM POSTS
    GROUP BY USER_ID
) PC -- 2. 인라인 뷰에 PC라는 별칭을 부여
JOIN USERS U ON PC.USER_ID = U.USER_ID; -- 3. USERS 테이블과 조인하여 사용자 정보를 가져온다
````

**방법 B: 일반 테이블을 먼저 명시**

`INNER JOIN`에서는 테이블의 순서가 결과에 영향을 주지 않으므로, 아래와 같이 작성해도 동일한 결과를 얻습니다.

```sql
-- USERS 테이블을 먼저 명시하고 인라인 뷰(PC)와 조인
SELECT
    PC.USER_ID,
    U.USERNAME,
    PC.POST_COUNT
FROM USERS U
JOIN (
    -- 사용자 ID별 게시글 수를 계산하는 서브쿼리
    SELECT USER_ID, COUNT(*) AS POST_COUNT
    FROM POSTS
    GROUP BY USER_ID
) PC ON PC.USER_ID = U.USER_ID;
```

-----

### 예제 2: 사용자별 좋아요 총 개수 조회

`LIKES` 테이블에서 사용자별 좋아요 수를 계산한 인라인 뷰(`A`)를 `USERS` 테이블과 `NATURAL JOIN` 하여 사용자 정보를 함께 조회합니다.

```sql
-- NATURAL JOIN 활용 예제
SELECT
    USER_ID,
    U.USERNAME,
    A.total_likes
FROM (
    -- 1. 사용자별로 받은 좋아요의 총 개수를 계산
    SELECT
        USER_ID,
        COUNT(*) AS total_likes
    FROM LIKES
    GROUP BY USER_ID
) A
NATURAL JOIN USERS U; -- 2. NATURAL JOIN을 사용해 공통 컬럼인 USER_ID로 조인
-- ON A.USER_ID = U.USER_ID 와 동일하게 작동합니다.
```

> **💡 `NATURAL JOIN` 이란?**
>
> 두 테이블 간에 이름과 데이터 타입이 동일한 모든 컬럼을 기준으로 자동으로 `JOIN`을 수행합니다. 코드가 간결해지지만, 예상치 못한 컬럼이 조인 조건에 포함될 수 있으므로 명시적인 `ON` 절 사용이 권장될 때도 있습니다.

-----

## 2\. 스칼라 서브쿼리 (Scalar Subquery)

스칼라 서브쿼리는 `SELECT` 절에서 사용되며, 단일 행, 단일 열의 값(하나의 값)을 반환해야 합니다. 주로 메인 쿼리의 각 행에 대한 추가 정보를 조회할 때 사용됩니다.

### 개념 정리

  - **동작 방식**: 메인 쿼리가 한 행씩 처리될 때마다 서브쿼리가 실행됩니다. 이를 \*\*연관 서브쿼리(Correlated Subquery)\*\*라고도 합니다.
  - **반환 값**: 반드시 하나의 값만 반환해야 합니다. 결과가 여러 행이거나 여러 열이면 오류가 발생합니다.
  - **성능**: 데이터 양이 많을 경우 메인 쿼리의 행 수만큼 서브쿼리가 반복 실행되므로 성능 저하의 원인이 될 수 있습니다.

-----

### 예제 1: 사용자의 상세 자기소개(BIO) 조회

`USERS` 테이블을 조회하면서, 각 사용자의 `USER_ID`를 이용해 `USER_PROFILES` 테이블에서 `BIO` 정보를 가져옵니다.

```sql
-- 스칼라 서브쿼리 == 연관 서브쿼리
-- 연관 서브쿼리: 서브쿼리가 한 번 실행되고 끝나는게 아니라
-- 바깥쪽 메인쿼리 한 행을 실행할때마다 반복 실행
SELECT
    U.USER_ID,
    U.USERNAME,
    -- 1. 메인 쿼리의 U.USER_ID 값을 받아 서브쿼리 실행
    (SELECT BIO FROM USER_PROFILES UP WHERE U.USER_ID = UP.USER_ID) AS BIO
FROM USERS U;
```

위 쿼리에서 스칼라 서브쿼리는 `USERS` 테이블의 각 행(사용자)에 대해 `U.USER_ID`를 받아 `USER_PROFILES` 테이블에서 일치하는 `BIO`를 찾아 반환합니다.

-----

### 예제 2: 피드별 좋아요 및 댓글 수 조회

`POSTS` 테이블을 조회하면서 각 피드(`POST_ID`)에 대한 좋아요 수와 댓글 수를 각각의 스칼라 서브쿼리를 통해 조회합니다.

**방법 A: `LEFT JOIN`과 인라인 뷰 사용**

```sql
SELECT
    P.POST_ID,
    P.CONTENT,
    -- 좋아요나 댓글이 없는 경우 NULL이 되므로 NVL 함수로 0 처리
    NVL(LC.LIKE_COUNT, 0) AS LIKE_COUNT,
    NVL(RC.REPLY_COUNT, 0) AS REPLY_COUNT
FROM POSTS P
-- 1. 좋아요 수를 계산하는 인라인 뷰와 LEFT JOIN
LEFT JOIN (
    SELECT POST_ID, COUNT(*) AS LIKE_COUNT
    FROM LIKES
    GROUP BY POST_ID
) LC ON P.POST_ID = LC.POST_ID
-- 2. 댓글 수를 계산하는 인라인 뷰와 LEFT JOIN
LEFT JOIN (
    SELECT POST_ID, COUNT(*) AS REPLY_COUNT
    FROM COMMENTS
    GROUP BY POST_ID
) RC ON RC.POST_ID = P.POST_ID
ORDER BY P.POST_ID;
```

> **💡 왜 `LEFT JOIN`을 사용할까?**
>
> `INNER JOIN`을 사용하면 좋아요나 댓글이 없는 게시물은 결과에서 누락됩니다. `LEFT JOIN`은 `POSTS` 테이블을 기준으로 모든 게시물을 포함하고, 일치하는 좋아요/댓글이 없는 경우 `NULL`로 표시하므로 `NVL` 함수를 통해 `0`으로 처리할 수 있습니다.

**방법 B: 스칼라 서브쿼리 사용**

JOIN 없이 `SELECT` 절에서 스칼라 서브쿼리를 사용하여 동일한 결과를 더 간결하게 얻을 수 있습니다.

```sql
SELECT
    p.post_id,
    p.content,
    -- 1. 메인 쿼리의 p.post_id를 받아 해당 게시물의 좋아요 수를 계산
    (SELECT COUNT(*) FROM LIKES l WHERE l.post_id = p.post_id) AS "좋아요 수",
    -- 2. 메인 쿼리의 p.post_id를 받아 해당 게시물의 댓글 수를 계산
    (SELECT COUNT(*) FROM COMMENTS c WHERE c.post_id = p.post_id) AS "댓글 수"
FROM
    POSTS p;
```

-----

## 3\. EXISTS 연산자

`EXISTS`는 서브쿼리의 결과 집합에 행이 존재하는지 여부를 확인하는 데 사용됩니다. 결과가 있으면 `TRUE`, 없으면 `FALSE`를 반환합니다.

### 개념 정리

  - **동작 방식**: 서브쿼리에서 조건을 만족하는 행이 **하나라도 발견되면** 즉시 `TRUE`를 반환하고 서브쿼리 실행을 중단합니다. 이 때문에 `COUNT(*)`나 `IN` 보다 효율적일 수 있습니다.
  - **`SELECT` 절**: `EXISTS`의 서브쿼리 `SELECT` 절에는 `SELECT 1`, `SELECT '*` 등 어떤 것을 써도 무방합니다. 실제 데이터를 반환하는 것이 아니라 행의 존재 여부만 체크하기 때문입니다.

-----

### 예제 1: 게시물을 한 번이라도 작성한 사용자 조회

`USERS` 테이블의 각 사용자에 대해 `POSTS` 테이블에 해당 사용자의 `user_id`가 존재하는지 확인합니다.

**방법 A: `JOIN` 사용**

```sql
-- DISTINCT를 사용하여 중복을 제거해야 함
SELECT DISTINCT P.USER_ID, U.USERNAME
FROM POSTS P
JOIN USERS U ON P.USER_ID = U.USER_ID
ORDER BY USER_ID;
```

**방법 B: `EXISTS` 사용**

`EXISTS`를 사용하면 `JOIN`으로 인한 중복이 발생하지 않아 `DISTINCT`를 사용할 필요가 없습니다.

```sql
SELECT
    U.USER_ID,
    u.username
FROM
    USERS u
WHERE
    -- 1. USERS 테이블의 각 u.user_id에 대해
    EXISTS (
        -- 2. POSTS 테이블에 동일한 user_id를 가진 행이 존재하는지 확인
        SELECT 1
        FROM POSTS p
        WHERE p.user_id = u.user_id
    );
```

-----

### 예제 2: 게시물을 한 번도 작성하지 않은 사용자 조회 (`NOT EXISTS`)

`EXISTS` 앞에 `NOT`을 붙여 서브쿼리의 결과가 존재하지 않는 경우(`FALSE`)가 `TRUE`로 평가되도록 합니다.

```sql
SELECT
    U.USER_ID,
    u.username
FROM
    USERS u
WHERE
    -- 1. USERS 테이블의 각 u.user_id에 대해
    NOT EXISTS (
        -- 2. POSTS 테이블에 동일한 user_id를 가진 행이 존재하지 않는 경우를 TRUE로 판단
        SELECT 1
        FROM POSTS p
        WHERE p.user_id = u.user_id
    )
ORDER BY U.USER_ID;
```
