
# SQL: DDL & DML


## I. DDL (Data Definition Language, 데이터 정의어)

DDL은 데이터베이스의 스키마(구조)를 정의하거나 변경, 삭제할 때 사용하는 언어입니다. 테이블이나 인덱스 같은 '데이터의 집' 자체를 짓고, 리모델링하고, 철거하는 역할을 합니다. 주요 명령어로는 `CREATE`, `ALTER`, `DROP`, `TRUNCATE`가 있습니다.

-----

### 1\. 테이블 생성: `CREATE TABLE`

`CREATE TABLE`은 데이터를 저장할 새로운 테이블을 만드는 가장 기본적인 DDL 명령어입니다. 테이블 생성 시 각 컬럼의 이름, 데이터 타입, 제약조건을 정의해야 합니다.

#### 데이터 타입 (Data Type)

컬럼에 저장될 데이터의 종류를 지정합니다.

| 데이터 타입 | 저장하는 데이터 | 예시 |
| :--- | :--- | :--- |
| **NUMBER** | 숫자 | 100, 3.14, -50 |
| **VARCHAR2(n)** | 가변 길이 문자열 (최대 n byte) | '안녕하세요', 'SQLD' |
| **DATE** | 날짜와 시간 | '2025-07-31' |

#### 제약조건 (Constraints)

데이터의 무결성을 보장하고, 올바른 데이터만 저장되도록 강제하는 규칙입니다.

| 제약조건 | 역할 | 비유 |
| :--- | :--- | :--- |
| **PRIMARY KEY** | 유일한 식별자 (NOT NULL + UNIQUE) | 주민등록번호 |
| **NOT NULL** | 필수 입력 (NULL 값 불허) | 회원가입 시 필수 아이디 |
| **UNIQUE** | 유일한 값 (중복 불허, NULL 허용) | 중복되지 않는 이메일 주소 |
| **CHECK** | 정해진 조건의 값만 허용 | 수강료는 0원 이상 |
| **DEFAULT** | 값 미입력 시 자동으로 설정되는 기본값 | 회원 등급 자동 'BRONZE' 부여 |

#### 📝 `CREATE TABLE` 예제: 온라인 강좌 테이블

```sql
-- '온라인 강좌' 정보를 담을 COURSES 테이블 생성
CREATE TABLE COURSES (
    course_id     NUMBER          CONSTRAINT pk_courses PRIMARY KEY,
    course_name   VARCHAR2(100)   CONSTRAINT nn_course_name NOT NULL,
    instructor    VARCHAR2(50)    NOT NULL, -- 제약조건 이름은 생략 가능
    price         NUMBER          DEFAULT 0 CHECK (price >= 0),
    start_date    DATE            DEFAULT SYSDATE
);
```

  * `CONSTRAINT 제약조건이름` 구문을 사용하면 각 제약조건에 이름을 부여하여 나중에 관리하기 용이합니다.

-----

### 2\. 관계 설정 및 성능 향상

#### `FOREIGN KEY` (외래 키)

\*\*외래 키(FK)\*\*는 한 테이블의 컬럼이 다른 테이블의 \*\*기본 키(PK)\*\*를 참조하게 하여, 테이블 간의 관계를 맺어주는 핵심 제약조건입니다. 이를 통해 존재하지 않는 데이터를 참조하는 등의 문제를 막아 **데이터 무결성**을 보장합니다.

```sql
-- 수강생 정보를 담을 STUDENTS 테이블
CREATE TABLE STUDENTS (
    student_id    NUMBER          CONSTRAINT pk_students PRIMARY KEY,
    student_name  VARCHAR2(50)    NOT NULL,
    email         VARCHAR2(100)   UNIQUE
);

-- 수강신청 정보를 담을 ENROLLMENTS 테이블 (두 테이블을 연결)
CREATE TABLE ENROLLMENTS (
    enrollment_id NUMBER          CONSTRAINT pk_enrollments PRIMARY KEY,
    s_id          NUMBER, -- STUDENTS의 PK를 참조
    course_id     NUMBER, -- COURSES의 PK를 참조
    enroll_date   DATE            DEFAULT SYSDATE,
    
    -- 외래 키(관계) 설정
    CONSTRAINT fk_enroll_student FOREIGN KEY (s_id) REFERENCES STUDENTS(student_id),
    CONSTRAINT fk_enroll_course FOREIGN KEY (course_id) REFERENCES COURSES(course_id)
);
```

  * **참조 무결성 옵션**: 부모 테이블의 데이터가 변경/삭제될 때 자식 테이블의 데이터를 어떻게 처리할지 결정합니다.
      * `ON DELETE CASCADE`: 부모 데이터 삭제 시, 참조하는 자식 데이터도 **함께 삭제**됩니다.
      * `ON DELETE SET NULL`: 부모 데이터 삭제 시, 자식 데이터의 FK 컬럼 값이 **NULL로 변경**됩니다.

#### `INDEX` (인덱스)

**인덱스**는 데이터베이스 테이블의 **검색(SELECT) 속도를 비약적으로 향상시키는** '찾아보기' 기능입니다. 데이터가 많은 테이블에서 `WHERE` 절이나 `JOIN` 조건에 자주 사용되는 컬럼에 생성하면 효과적입니다.

```sql
-- COURSES 테이블의 강사명(instructor) 컬럼으로 검색 속도를 높이기 위해 인덱스 생성
CREATE INDEX idx_courses_instructor ON COURSES(instructor);
```

  * **PRIMARY KEY**와 **UNIQUE** 제약조건을 설정한 컬럼에는 데이터베이스가 **자동으로 고유 인덱스를 생성**해 주므로 이미 검색 속도가 빠릅니다.

-----

### 3\. 테이블 구조 변경 및 삭제

#### `ALTER TABLE`

이미 생성된 테이블의 구조를 변경(컬럼 추가/수정/삭제, 제약조건 추가/삭제 등)하는 '리모델링' 명령어입니다.

  * **컬럼 추가 (`ADD`)**: `ALTER TABLE COURSES ADD (instructor_email VARCHAR2(100));`
  * **컬럼 수정 (`MODIFY`)**: `ALTER TABLE COURSES MODIFY (course_name VARCHAR2(150));`
  * **컬럼 삭제 (`DROP COLUMN`)**: `ALTER TABLE COURSES DROP COLUMN instructor_email;`
  * **이름 변경 (`RENAME`)**:
      * 컬럼: `ALTER TABLE COURSES RENAME COLUMN instructor TO instructor_name;`
      * 테이블: `RENAME COURSES TO ONLINE_COURSES;`
  * **제약조건 추가/삭제 (`ADD/DROP CONSTRAINT`)**:
      * 추가: `ALTER TABLE ONLINE_COURSES ADD CONSTRAINT uq_instructor_name UNIQUE (instructor_name);`
      * 삭제: `ALTER TABLE ONLINE_COURSES DROP CONSTRAINT uq_instructor_name;`

#### `DROP TABLE`

테이블의 모든 데이터 및 구조를 **완전히 삭제**하는 '철거' 명령어입니다. 복구가 불가능하므로 신중하게 사용해야 합니다.

```sql
DROP TABLE TEST_TABLE;
```

  * `CASCADE CONSTRAINTS` 옵션: 다른 테이블이 참조하고 있는 테이블을 삭제할 때, 관련된 외래 키 제약조건까지 모두 삭제하며 강제로 테이블을 제거합니다.

-----

### 4\. 삭제 명령어 비교: `DELETE` vs. `TRUNCATE` vs. `DROP`

세 명령어는 데이터를 삭제하지만, 동작 방식과 특징이 완전히 다릅니다.

| 구분 | `DELETE` (휴지통) | `TRUNCATE` (포맷) | `DROP` (철거) |
| :--- | :--- | :--- | :--- |
| **명령어 종류** | DML (데이터 조작어) | DDL (데이터 정의어) | DDL (데이터 정의어) |
| **삭제 대상** | 데이터 (행 단위) | 모든 데이터 (공간 초기화) | 테이블 구조 + 모든 데이터 |
| **`WHERE` 절** | **사용 가능** | 사용 불가능 | 사용 불가능 |
| **`ROLLBACK`** | **가능** | 불가능 | 불가능 |
| **속도** | 느림 | 매우 빠름 | 빠름 |

-----

-----

## II. DML (Data Manipulation Language, 데이터 조작어)

DML은 테이블에 데이터를 **추가(`INSERT`)**, **수정(`UPDATE`)**, **삭제(`DELETE`)** 할 때 사용하는 '인테리어' 작업을 담당하는 언어입니다.

-----

### 1\. 데이터 추가: `INSERT`

테이블에 새로운 행(Row)을 추가합니다.

#### 기본 `INSERT`

한 번에 한 행의 데이터를 직접 추가합니다. 컬럼명을 명시하는 것이 더 안전하고 권장되는 방식입니다.

```sql
-- 1. 컬럼명 생략 (테이블 컬럼 순서대로 모든 값 입력)
INSERT INTO STUDENTS VALUES (101, '김철수', 'chulsoo.kim@example.com');

-- 2. 컬럼명 명시 (권장 방식)
INSERT INTO STUDENTS (student_id, student_name, email)
VALUES (102, '이영희', 'younghee.lee@example.com');
```

#### 서브쿼리를 이용한 `INSERT`

`SELECT` 문의 조회 결과를 통째로 다른 테이블에 추가합니다. 대량 데이터 백업이나 이전에 유용합니다.

```sql
-- 'SQLD 정복하기' 강좌 수강생 명단을 MARKETING_TARGETS 테이블에 추가
INSERT INTO MARKETING_TARGETS (student_id, student_name)
SELECT s.student_id, s.student_name
FROM STUDENTS s
INNER JOIN ENROLLMENTS e ON s.student_id = e.student_id
WHERE e.course_id = 1;
```

#### [심화] 조건부 `INSERT ALL` (Oracle)

하나의 `SELECT` 문으로 여러 테이블에 조건부로 데이터를 동시에 추가하는 강력한 기능입니다.

```sql
-- 수강료에 따라 고가/저가 강좌 테이블에 나눠서 저장
INSERT ALL
    WHEN price >= 30000 THEN
        INTO PREMIUM_COURSES (course_id, course_name, price)
        VALUES (course_id, course_name, price)
    WHEN price <= 10000 THEN
        INTO BASIC_COURSES (course_id, course_name, price)
        VALUES (course_id, course_name, price)
SELECT course_id, course_name, price
FROM COURSES;
```

-----

### 2\. 데이터 수정: `UPDATE`

기존에 존재하는 행의 컬럼 값을 수정합니다.

#### 기본 `UPDATE`

`UPDATE 테이블명 SET 컬럼=값 WHERE 조건` 형태로 사용합니다. `WHERE` 절을 통해 수정할 대상을 정확히 지정하는 것이 매우 중요합니다.

```sql
-- 학생 ID가 102인 학생의 이메일과 이름을 변경
UPDATE STUDENTS
   SET student_name = '이영희 주니어',
       email = 'junior.lee@example.com'
 WHERE student_id = 102;
```

  * 🚨 **`WHERE` 절을 생략하면** 테이블의 **모든 행**이 수정되는 대참사가 발생할 수 있습니다.

#### 서브쿼리를 이용한 `UPDATE`

다른 테이블의 값을 참조하여 동적으로 데이터를 수정할 수 있습니다.

```sql
-- SET 절에서 서브쿼리 사용: 신규 강좌의 수강료를 전체 강좌의 평균가로 책정
UPDATE COURSES
   SET price = (SELECT AVG(price) FROM COURSES) -- 반드시 단일 값을 반환해야 함
 WHERE course_id = 10;

-- WHERE 절에서 서브쿼리 사용: 수강생 5명 이상인 인기 강좌만 수강료 10% 인상
UPDATE COURSES
   SET price = price * 1.1
 WHERE course_id IN (SELECT course_id
                     FROM ENROLLMENTS
                     GROUP BY course_id
                     HAVING COUNT(*) >= 5);
```

-----

### 3\. 데이터 삭제 및 병합: `DELETE` & `MERGE`

#### 데이터 삭제: `DELETE`

테이블에서 특정 행을 삭제합니다. `UPDATE`와 마찬가지로 `WHERE` 절이 핵심입니다.

```sql
-- 101번 학생의 1번 강좌 수강 신청 기록 삭제
DELETE FROM ENROLLMENTS
 WHERE student_id = 101 AND course_id = 1;
```

  * `WHERE` 절 없는 `DELETE`는 `TRUNCATE`와 결과는 같지만, 동작 방식(속도, 롤백 가능 여부)이 다릅니다.

#### 데이터 병합: `MERGE` (UPSERT)

**DML의 끝판왕.** 두 테이블을 비교하여, 조건이 일치하면 `UPDATE`, 일치하지 않으면 `INSERT`를 수행하는 '데이터 동기화'에 특화된 명령어입니다.

```sql
-- DAILY_UPDATES(소스) 테이블을 기준으로 STUDENTS(목표) 테이블을 동기화
MERGE INTO STUDENTS s -- 목표 테이블
USING (SELECT * FROM DAILY_UPDATES) d -- 소스 테이블
   ON (s.student_id = d.student_id) -- 비교 조건
 WHEN MATCHED THEN -- 조건 일치 시 (기존 학생)
      UPDATE SET s.email = d.email -- 정보 업데이트
 WHEN NOT MATCHED THEN -- 조건 불일치 시 (신규 학생)
      INSERT (student_id, student_name, email)
      VALUES (d.student_id, d.student_name, d.email); -- 신규 데이터 추가
```
