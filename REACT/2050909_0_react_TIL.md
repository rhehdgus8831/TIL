알겠습니다. React 최적화 관련 학습 내용을 별도의 MD 파일로 깔끔하게 정리해 드릴게요.

-----

# React 성능 최적화 학습 노트

## 1\. React 렌더링과 최적화의 필요성

React는 **상태(state)나 속성(props)이 변경**될 때 해당 컴포넌트와 그 모든 **자식 컴포넌트들을 다시 렌더링**하여 UI를 최신 상태로 유지합니다. 대부분의 경우 이 과정은 매우 빠르고 효율적이지만, 애플리케이션의 규모가 커지고 복잡해지면 불필요한 리렌더링이 발생하여 성능 저하의 원인이 될 수 있습니다.

### 1.1. 불필요한 리렌더링이 발생하는 경우

  - **부모 컴포넌트의 리렌더링**: 부모 컴포넌트의 상태가 변경되면, 자신에게 전달되는 **props가 변경되지 않았음에도 불구하고** 모든 자식 컴포넌트들이 기본적으로 다시 렌더링됩니다.
  - **새로운 함수 객체 생성**: 함수형 컴포넌트는 렌더링될 때마다 내부에 선언된 함수들이 **새로운 객체로 다시 생성**됩니다. 이 함수가 자식 컴포넌트에 prop으로 전달되면, 자식은 prop이 변경되었다고 인식하여 불필요한 리렌더링을 유발할 수 있습니다.

이러한 문제를 해결하고 성능을 향상시키기 위해 React는 몇 가지 최적화 도구를 제공합니다.

-----

## 2\. `React.memo`를 이용한 리렌더링 방지

`React.memo`는 \*\*고차 컴포넌트(Higher-Order Component, HOC)\*\*로, 컴포넌트의 렌더링 결과를 \*\*메모이징(Memoizing)\*\*하여 불필요한 리렌더링을 방지합니다.

`React.memo`로 감싸진 컴포넌트는 자신의 props에 대한 \*\*얕은 비교(shallow comparison)\*\*를 수행하여, props가 이전 렌더링과 동일할 경우 리렌더링을 실행하지 않고 이전에 메모이징된 결과를 재사용합니다.

### `IconButton.jsx` 코드 예시

`Counter` 컴포넌트가 리렌더링될 때마다 `IconButton`도 함께 리렌더링됩니다. `React.memo`를 사용하면 `IconButton`에 전달되는 props( `icon`, `onClick`, `children`)가 변경되지 않는 한, 리렌더링을 건너뛸 수 있습니다.

```jsx
// src/optimizing/components/UI/IconButton.jsx
import React from 'react';
import { log } from '../../log.js';

const IconButton = ({ children, icon, ...props }) => {
  log('<IconButton /> rendered', 2);

  const Icon = icon;
  return (
    <button
      {...props}
      className='button'>
      <Icon className='button-icon' />
      <span className='button-text'>{children}</span>
    </button>
  );
};

// React.memo로 컴포넌트를 감싸주면, props가 변경되지 않았을 때 리렌더링을 방지합니다.
export default React.memo(IconButton);
```

-----

## 3\. `useCallback`을 이용한 함수 메모이징

`React.memo`를 사용하더라도, prop으로 전달되는 함수가 렌더링마다 계속 새로 생성된다면 최적화 효과를 볼 수 없습니다. `useCallback` Hook은 **함수 자체를 메모이징**하여, 의존성 배열(`dependency array`)의 값이 변경되지 않는 한 함수를 재생성하는 것을 방지합니다.

### `Counter.jsx` 코드 예시

`decrementHandler`와 `incrementHandler`는 `Counter` 컴포넌트가 렌더링될 때마다 새로 생성됩니다. 이를 `useCallback`으로 감싸고 의존성 배열을 `[]`로 설정하면, 이 함수들은 컴포넌트가 처음 마운트될 때 단 한 번만 생성되고 이후에는 계속 재사용됩니다. 결과적으로 `IconButton`의 `onClick` prop은 항상 동일한 함수를 참조하게 되어 `React.memo`의 최적화가 효과적으로 동작하게 됩니다.

```jsx
// src/optimizing/components/Counter/Counter.jsx
import React, { useCallback, useState } from 'react';
import IconButton from '../UI/IconButton';
import MinusIcon from '../UI/Icons/MinusIcon';
import PlusIcon from '../UI/Icons/PlusIcon';
import CounterOutput from './CounterOutput';
import { log } from '../../log';
import CounterHistory from './CounterHistory.jsx';

const Counter = ({ initialCount }) => {
    log('<Counter /> rendered', 1);

    const [counterChanges, setCounterChanges] = useState([{ id: Math.random().toString(), value: initialCount }]);

    // useCallback을 사용하여 함수가 불필요하게 재생성되는 것을 방지합니다.
    // 의존성 배열이 비어있으므로, 이 함수들은 최초 렌더링 시에만 생성됩니다.
    const decrementHandler = useCallback(() => {
        setCounterChanges(prev =>
            [{ id: Math.random().toString(), value: -1 }, ...prev]);
    }, []);

    const incrementHandler = useCallback(() => {
        setCounterChanges(prev =>
            [{ id: Math.random().toString(), value: 1 }, ...prev]);
    }, []);

    const totalCount = counterChanges.reduce((acc, curr) => acc + curr.value, 0);

    return (
        <section className="counter">
            {/* ... */}
            <p>
                <IconButton icon={MinusIcon} onClick={decrementHandler}>Decrement</IconButton>
                <CounterOutput value={totalCount} />
                <IconButton icon={PlusIcon} onClick={incrementHandler}>Increment</IconButton>
            </p>
            <CounterHistory history={counterChanges} />
        </section>
    );
};

export default Counter;
```

-----

## 4\. `key` Prop을 이용한 상태 초기화

React에서 `key` prop은 리스트 렌더링 시 항목을 식별하는 용도 외에도, **컴포넌트의 인스턴스를 제어**하는 강력한 기능을 제공합니다. 컴포넌트에 전달된 `key` 값이 변경되면, React는 이전 컴포넌트 인스턴스를 \*\*제거(unmount)하고 완전히 새로운 인스턴스를 생성(mount)\*\*합니다.

이러한 특성을 이용하면 컴포넌트의 모든 내부 상태를 **초기 상태로 리셋**하는 효과를 쉽게 구현할 수 있습니다.

### `App.jsx` 코드 예시

`ConfigureCounter` 컴포넌트에서 새로운 숫자를 "Set"하면 `App` 컴포넌트의 `chosenCount` 상태가 업데이트됩니다. 이 `chosenCount` 값을 `Counter` 컴포넌트의 `key` prop으로 전달하면, `key`가 바뀔 때마다 `Counter` 컴포넌트가 리셋됩니다. 그 결과, `Counter` 내부의 `counterChanges` 상태가 `initialCount` 값으로 초기화됩니다.

```jsx
// src/App.jsx
import React, { useState } from 'react';
import Counter from './optimizing/components/Counter/Counter';
import Header from './optimizing/components/Header';
import { log } from './optimizing/log';
import './App.css';
import ConfigureCounter from './optimizing/components/Counter/ConfigureCounter.jsx';

const App = () => {
    log('<App /> rendered');
    const [chosenCount, setChosenCount] = useState(0);

    const setCounterHandler = number => {
        setChosenCount(number);
    };

    return (
        <>
            <Header />
            <main>
                <ConfigureCounter onSet={setCounterHandler} />
                {/* `chosenCount`를 key로 전달합니다. 
                  `chosenCount` 값이 변경되면 React는 이전 Counter 컴포넌트를 버리고 
                  새로운 Counter 컴포넌트를 생성하여 상태를 초기화합니다.
                */}
                <Counter key={chosenCount} initialCount={chosenCount} />
            </main>
        </>
    );
};

export default App;
```

-----

## 5\. 핵심 정리

| 도구             | 사용 목적                                              | 주요 특징                                                        |
| ---------------- | ------------------------------------------------------ | ---------------------------------------------------------------- |
| **`React.memo`** | **컴포넌트**의 불필요한 리렌더링 방지 (메모이징)       | `props`를 얕게 비교하여 변경 여부를 판단                         |
| **`useCallback`**| **함수**의 불필요한 재생성 방지 (메모이징)               | 의존성 배열의 값이 변경될 때만 함수를 재생성                     |
| **`key` Prop** | 컴포넌트의 **상태를 초기화**하고 인스턴스를 재생성     | `key` 값이 변경되면 컴포넌트를 unmount 후 mount 시킴             |
