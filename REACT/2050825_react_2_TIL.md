# React 학습 노트: 이벤트 바인딩

## 1\. 이벤트 바인딩(Event Binding)이란?

이벤트 바인딩은 사용자의 특정 행동(클릭, 입력, 마우스 오버 등)인 **이벤트**가 발생했을 때, 해당 이벤트를 처리할 \*\*함수(이벤트 핸들러)\*\*를 연결하여 실행시키는 과정을 의미합니다. 🖱️➡️👩‍💻

-----

## 2\. Vanilla JS vs React 이벤트 바인딩

### 2.1. 바닐라 JS (Vanilla JavaScript)

바닐라 JS에서는 일반적으로 `addEventListener` 메서드를 사용하여 DOM 요소에 이벤트를 직접 연결합니다.

```javascript
// 1. DOM에서 버튼 요소를 선택
const button = document.querySelector('button');

// 2. 'click' 이벤트가 발생하면 지정된 콜백 함수를 실행
button.addEventListener('click', function() {
    console.log('Button was clicked!');
});
```

### 2.2. 리액트 (React)

React에서는 JSX 문법을 사용하여 DOM 요소에 이벤트 핸들러를 직접 연결합니다. 이는 더 선언적이고 직관적인 방식을 제공합니다.

**주요 차이점:**

| 구분 | 바닐라 JS | 리액트 (React) |
| --- | --- | --- |
| **이벤트 이름** | 소문자 (`onclick`) | **카멜 케이스** (`onClick`) |
| **핸들러 전달** | 문자열 (`"handleClick()"`) | **함수 자체** (`{handleClick}`) |
| **기본 동작 방지** | `e.preventDefault()` | 동일하지만, `return false;`는 동작하지 않음 |

**`src/components/Counter.jsx` 예제**

```jsx
import React, { useState } from 'react';

const Counter = () => {
    const [count, setCount] = useState(10);

    // 컴포넌트 내부에 이벤트 핸들러 함수를 정의
    const increaseHandler = () => setCount(count + 1);
    const decreaseHandler = () => setCount(count - 1);

    return (
        <div>
            <h1>숫자: {count}</h1>
            {/* JSX의 onClick 속성에 핸들러 함수를 직접 연결 */}
            <button onClick={increaseHandler}>증가</button>
            <button onClick={decreaseHandler}>감소</button>
        </div>
    );
};

export default Counter;
```

> **💡 `this` 바인딩에 대하여**
> 과거 클래스 컴포넌트에서는 `this`가 가리키는 대상이 달라지는 문제 때문에 `bind` 메서드를 사용해야 했습니다. 하지만 **함수형 컴포넌트**는 `this`를 사용하지 않으므로, 이러한 걱정 없이 편리하게 이벤트 핸들러를 작성할 수 있습니다.

-----

## 3\. 리액트의 이벤트 처리 방식과 가상돔(Virtual DOM)

React가 인라인 방식으로 이벤트 핸들러를 처리하는 것은 \*\*가상돔(Virtual DOM)\*\*과 깊은 관련이 있습니다.

React는 UI의 이전 상태와 새로운 상태를 가상돔에서 비교(Diffing)하여 변경된 부분만 실제 DOM에 효율적으로 업데이트합니다. 이벤트 핸들러가 컴포넌트 내부에 정의되어 있으면, 이 핸들러는 컴포넌트 인스턴스의 일부로 취급되어 React의 렌더링 및 비교 알고리즘에 더 효율적으로 통합될 수 있습니다.

-----

## 4\. 이벤트 핸들러 선언 방식

이벤트 핸들러를 선언하고 바인딩하는 방법은 크게 두 가지로 나눌 수 있으며, 각각의 장단점이 있습니다.

### 4.1. 컴포넌트 내부에 함수로 선언 후 바인딩

가장 일반적이고 권장되는 방식입니다. 컴포넌트의 `state`나 `props`에 접근해야 할 때 반드시 사용해야 합니다.

**장점**:

- 코드가 직관적이고 가독성이 높습니다.
- 컴포넌트의 `props`와 `state`에 자유롭게 접근할 수 있습니다.

**단점**:

- 컴포넌트가 리렌더링될 때마다 함수가 재생성될 수 있습니다. (성능에 미미한 영향, `useCallback`으로 최적화 가능)

**`src/components/practice/CheckBoxStyle.jsx` 예제**

```jsx
const CheckBoxStyle = () => {
    const [checked, setChecked] = useState(false);

    // 컴포넌트 내부에 핸들러를 선언하여 'setChecked'라는 state 변경 함수에 접근
    const checkHandler = (e) => {
        setChecked(e.target.checked);
    }

    return (
        <div className='checkbox-container'>
            <input
                type='checkbox'
                onChange={checkHandler} // 선언된 핸들러를 바인딩
                checked={checked}
            />
            {/* ... */}
        </div>
    );
};
```

### 4.2. 인라인에서 화살표 함수로 직접 바인딩

간단한 로직을 처리할 때나, 핸들러에 인자를 전달해야 할 때 유용하게 사용됩니다.

**장점**:

- 핸들러를 따로 선언할 필요 없이 간결하게 작성할 수 있습니다.
- 핸들러에 특정 값을 인자로 넘기기 편리합니다.

**단점**:

- 렌더링될 때마다 새로운 함수가 생성되므로, 불필요한 메모리 사용과 성능 저하를 유발할 수 있습니다. (특히 자식 컴포넌트에 props로 전달할 때 주의)
- 로직이 복잡해지면 가독성이 떨어집니다.

**`src/components/new-expense/ExpenseForm.jsx` 예제**

```jsx
const ExpenseForm = () => {
    const [title, setTitle] = useState('');

    return (
        <form>
            <div className="new-expense__control">
                <label>Title</label>
                {/* 인라인 화살표 함수를 사용하여 이벤트 객체(e)에서 값을 바로 state에 저장 */}
                <input type="text" onInput={e => setTitle(e.target.value)} />
            </div>
            {/* ... */}
        </form>
    );
};
```

### 결론

| 상황 | 추천 방식 | 이유 |
| --- | --- | --- |
| **일반적인 경우** | **컴포넌트 내부에 함수 선언** | 가독성과 유지보수, 성능 최적화(useCallback)에 유리합니다. |
| **로직이 매우 간단할 때** | **인라인 화살표 함수** | 코드를 간결하게 유지할 수 있습니다. |
| **핸들러에 인자를 전달해야 할 때** | **인라인 화살표 함수** | `onClick={() => handleDelete(id)}` 와 같이 쉽게 인자를 넘길 수 있습니다. |